<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPS排行榜</title>
    <link rel="stylesheet" href="dps-ranking-overlay.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="ranking-overlay-container">
        <!-- 悬浮窗头部（可拖拽） -->
        <div class="ranking-header" id="rankingHeader">
            <div class="ranking-title">
                <span class="ranking-icon">⚔️</span>
                <span class="title-text">DPS排行榜</span>
            </div>
            <div class="ranking-controls">
                <button class="ranking-control-btn pin-btn" id="pinBtn" title="切换置顶">
                    <span>📌</span>
                </button>
                <button class="ranking-control-btn close-btn" id="closeBtn" title="关闭">
                    <span>✕</span>
                </button>
            </div>
        </div>

        <!-- DPS排行榜内容 -->
        <div class="ranking-content">
            <div class="ranking-list" id="rankingList">
                <!-- 动态生成的排行榜项目 -->
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        let isPinned = true;
        let updateInterval;
        let playersData = {};
        let lastRankingHash = '';
        let lastPlayerRanks = {}; // 记录上次的玩家排名
        
        // 当前玩家UID
        window.currentPlayerUid = null;
        
        // DOM元素
        let rankingList, pinBtn, closeBtn;
        
        // 初始化
        function initializeRankingOverlay() {
            // 获取DOM元素
            rankingList = document.getElementById('rankingList');
            pinBtn = document.getElementById('pinBtn');
            closeBtn = document.getElementById('closeBtn');
            
            bindEvents();
            updatePinButton();
            startDataUpdate();
        }
        
        // 绑定事件
        function bindEvents() {
            // 置顶按钮
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    isPinned = !isPinned;
                    ipcRenderer.invoke('ranking-overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            }
            
            // 关闭按钮
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    ipcRenderer.invoke('ranking-overlay-close');
                });
            }
            
            // 接收统计数据更新
            ipcRenderer.on('stats-updated', (event, data) => {
                updatePlayersData(data);
                updateRankingDisplay();
            });
            
            // 接收清空数据事件
            ipcRenderer.on('stats-cleared', () => {
                playersData = {};
                lastRankingHash = ''; // 重置哈希值以确保DOM更新
                lastPlayerRanks = {}; // 重置玩家排名记录
                updateRankingDisplay();
            });
            
            // 接收当前玩家UID更新
            ipcRenderer.on('player-uid-updated', (event, uid) => {
                window.currentPlayerUid = uid;
                console.log('DPS排行榜收到玩家UID更新:', uid);
                updateRankingDisplay(); // 重新渲染排行榜
            });
        }
        
        // 更新置顶按钮状态
        function updatePinButton() {
            if (pinBtn) {
                if (isPinned) {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = '点击取消置顶';
                } else {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = '点击置顶显示';
                }
            }
        }
        
        // 开始数据更新
        function startDataUpdate() {
            // 每100ms更新一次显示
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                updateRankingDisplay();
            }, 100);
        }
        
        // 更新玩家数据
        function updatePlayersData(data) {
            if (data && data.users) {
                // 如果接收到空的用户数据，清空本地数据
                if (Object.keys(data.users).length === 0) {
                    playersData = {};
                    return;
                }
                
                Object.keys(data.users).forEach(uid => {
                    const userData = data.users[uid];
                    playersData[uid] = {
                        uid: uid,
                        totalDamage: userData.totalDamage || 0,
                        skills: userData.skills || [],
                        realtimeDps: userData.realtimeDps || 0
                    };
                });
            }
        }
        
        // 获取职业名称
        function getRoleNameBySkills(skills) {
            if (!skills || !Array.isArray(skills) || skills.length === 0) {
                return '未知';
            }
            
            // 遍历技能列表，找到匹配的职业
            for (const skill of skills) {
                switch (skill) {
                    case 1241:
                        return '射线';
                    case 55302:
                        return '协奏';
                    case 20301:
                        return '愈合';
                    case 1518:
                        return '惩戒';
                    case 2306:
                        return '狂音';
                    case 120902:
                        return '冰矛';
                    case 1714:
                        return '居合';
                    case 44701:
                        return '月刃';
                    case 220112:
                    case 2203622:
                        return '鹰弓';
                    case 1700827:
                        return '狼弓';
                    case 1419:
                        return '空枪';
                    case 1418:
                        return '重装';
                    case 2405:
                        return '防盾';
                    case 2406:
                        return '光盾';
                    case 199902:
                        return '岩盾';
                    default:
                        continue;
                }
            }
            
            return '未知';
        }
        
        // 格式化数字
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
        
        // 更新排行榜显示
        function updateRankingDisplay() {
            if (!rankingList) return;
            
            // 转换为数组并按总伤害排序
            const sortedPlayers = Object.values(playersData)
                .filter(player => player.totalDamage > 0)
                .sort((a, b) => b.totalDamage - a.totalDamage);
            
            // 生成数据哈希值用于检测变化（包含实时DPS）
            const currentHash = JSON.stringify(sortedPlayers.map(p => ({
                uid: p.uid,
                totalDamage: p.totalDamage,
                skills: p.skills,
                realtimeDps: p.realtimeDps
            })));
            
            // 如果数据没有变化，不更新DOM
            if (currentHash === lastRankingHash) {
                return;
            }
            
            const isFirstLoad = lastRankingHash === '';
            
            // 检测新玩家和排名变化
            const currentPlayerRanks = {};
            const newPlayers = new Set();
            const rankChangedPlayers = new Set();
            
            sortedPlayers.forEach((player, index) => {
                const rank = index + 1;
                currentPlayerRanks[player.uid] = rank;
                
                if (!lastPlayerRanks[player.uid]) {
                    // 新玩家
                    newPlayers.add(player.uid);
                } else if (lastPlayerRanks[player.uid] !== rank) {
                    // 排名变化的玩家
                    rankChangedPlayers.add(player.uid);
                }
            });
            
            lastRankingHash = currentHash;
            lastPlayerRanks = currentPlayerRanks;
            
            if (sortedPlayers.length === 0) {
                rankingList.innerHTML = '<div class="no-data">暂无数据</div>';
                return;
            }
            
            // 智能显示逻辑：只显示11项
            let displayPlayers = [];
            let currentPlayerUid = null;
            
            // 获取当前玩家UID（从main.js传递过来）
            if (window.currentPlayerUid) {
                currentPlayerUid = window.currentPlayerUid;
            }
            
            if (currentPlayerUid) {
                // 找到当前玩家的排名
                const currentPlayerIndex = sortedPlayers.findIndex(p => p.uid === currentPlayerUid);
                
                if (currentPlayerIndex !== -1 && currentPlayerIndex < 11) {
                    // 用户在前11名，显示前11名
                    displayPlayers = sortedPlayers.slice(0, 11);
                } else if (currentPlayerIndex !== -1 && currentPlayerIndex >= 11) {
                    // 用户在11名之后，显示前10名 + 用户
                    displayPlayers = [
                        ...sortedPlayers.slice(0, 10),
                        sortedPlayers[currentPlayerIndex]
                    ];
                } else {
                    // 找不到当前用户，显示前11名
                    displayPlayers = sortedPlayers.slice(0, 11);
                }
            } else {
                // 没有当前用户信息，显示前11名
                displayPlayers = sortedPlayers.slice(0, 11);
            }
            
            // 获取最高伤害作为100%基准
            const maxDamage = sortedPlayers[0].totalDamage;
            
            // 生成排行榜HTML
            const html = displayPlayers.map((player) => {
                const percentage = (player.totalDamage / maxDamage) * 100;
                const roleName = getRoleNameBySkills(player.skills);
                const actualRank = sortedPlayers.findIndex(p => p.uid === player.uid) + 1;
                const isCurrentPlayer = currentPlayerUid && player.uid === currentPlayerUid;
                
                // 决定是否添加动画类
                let animationClass = '';
                if (isFirstLoad || newPlayers.has(player.uid) || rankChangedPlayers.has(player.uid)) {
                    animationClass = ' initial-load';
                }
                
                // 为当前玩家添加特殊标识类，但不添加发光效果
                let playerClass = '';
                if (isCurrentPlayer) {
                    playerClass = ' current-player';
                }
                
                return `
                    <div class="ranking-item${animationClass}${playerClass}" data-rank="${actualRank}">
                        <div class="ranking-info">
                            <span class="rank-number">#${actualRank}</span>
                            <span class="player-role">${roleName}</span>
                            <span class="player-uid">${player.uid}</span>
                            <span class="damage-value">${formatNumber(player.totalDamage)} (${formatNumber(player.realtimeDps)}/s)</span>
                        </div>

                        <div class="damage-bar">
                            <div class="damage-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            rankingList.innerHTML = html;
            
            // 自动调整窗口大小
            adjustWindowSize();
        }
        
        // 动态调整窗口大小
        function adjustWindowSize() {
            setTimeout(() => {
                // 计算实际显示的条目数量
                const rankingItems = document.querySelectorAll('.ranking-item');
                const itemCount = rankingItems.length;
                
                // 基础高度：头部区域约60px + 内边距约32px
                const baseHeight = 92;
                // 每个条目的高度：min-height 45px + padding 16px = 61px
                const itemHeight = 61;
                // 计算总高度，最少显示1个条目的高度
                const totalHeight = baseHeight + Math.max(1, itemCount) * itemHeight;
                
                ipcRenderer.invoke('ranking-overlay-resize', {
                    width: 300,
                    height: totalHeight
                });
            }, 50);
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', initializeRankingOverlay);
        
        // 窗口关闭时清理
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>