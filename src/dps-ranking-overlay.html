<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPSæ’è¡Œæ¦œ</title>
    <link rel="stylesheet" href="dps-ranking-overlay.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="ranking-overlay-container">
        <!-- æ‚¬æµ®çª—å¤´éƒ¨ï¼ˆå¯æ‹–æ‹½ï¼‰ -->
        <div class="ranking-header" id="rankingHeader">
            <div class="ranking-title">
                <span class="ranking-icon">âš”ï¸</span>
                <span class="title-text">DPSæ’è¡Œæ¦œ</span>
            </div>
            <div class="ranking-controls">
                <button class="ranking-control-btn pin-btn" id="pinBtn" title="åˆ‡æ¢ç½®é¡¶">
                    <span>ğŸ“Œ</span>
                </button>
                <button class="ranking-control-btn close-btn" id="closeBtn" title="å…³é—­">
                    <span>âœ•</span>
                </button>
            </div>
        </div>

        <!-- DPSæ’è¡Œæ¦œå†…å®¹ -->
        <div class="ranking-content">
            <div class="ranking-list" id="rankingList">
                <!-- åŠ¨æ€ç”Ÿæˆçš„æ’è¡Œæ¦œé¡¹ç›® -->
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        let isPinned = true;
        let updateInterval;
        let playersData = {};
        let lastRankingHash = '';
        let lastPlayerRanks = {}; // è®°å½•ä¸Šæ¬¡çš„ç©å®¶æ’å
        
        // å½“å‰ç©å®¶UID
        window.currentPlayerUid = null;
        
        // DOMå…ƒç´ 
        let rankingList, pinBtn, closeBtn;
        
        // åˆå§‹åŒ–
        function initializeRankingOverlay() {
            // è·å–DOMå…ƒç´ 
            rankingList = document.getElementById('rankingList');
            pinBtn = document.getElementById('pinBtn');
            closeBtn = document.getElementById('closeBtn');
            
            bindEvents();
            updatePinButton();
            startDataUpdate();
        }
        
        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            // ç½®é¡¶æŒ‰é’®
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    isPinned = !isPinned;
                    ipcRenderer.invoke('ranking-overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            }
            
            // å…³é—­æŒ‰é’®
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    ipcRenderer.invoke('ranking-overlay-close');
                });
            }
            
            // æ¥æ”¶ç»Ÿè®¡æ•°æ®æ›´æ–°
            ipcRenderer.on('stats-updated', (event, data) => {
                updatePlayersData(data);
                updateRankingDisplay();
            });
            
            // æ¥æ”¶æ¸…ç©ºæ•°æ®äº‹ä»¶
            ipcRenderer.on('stats-cleared', () => {
                playersData = {};
                lastRankingHash = ''; // é‡ç½®å“ˆå¸Œå€¼ä»¥ç¡®ä¿DOMæ›´æ–°
                lastPlayerRanks = {}; // é‡ç½®ç©å®¶æ’åè®°å½•
                updateRankingDisplay();
            });
            
            // æ¥æ”¶å½“å‰ç©å®¶UIDæ›´æ–°
            ipcRenderer.on('player-uid-updated', (event, uid) => {
                window.currentPlayerUid = uid;
                console.log('DPSæ’è¡Œæ¦œæ”¶åˆ°ç©å®¶UIDæ›´æ–°:', uid);
                updateRankingDisplay(); // é‡æ–°æ¸²æŸ“æ’è¡Œæ¦œ
            });
        }
        
        // æ›´æ–°ç½®é¡¶æŒ‰é’®çŠ¶æ€
        function updatePinButton() {
            if (pinBtn) {
                if (isPinned) {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = 'ç‚¹å‡»å–æ¶ˆç½®é¡¶';
                } else {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = 'ç‚¹å‡»ç½®é¡¶æ˜¾ç¤º';
                }
            }
        }
        
        // å¼€å§‹æ•°æ®æ›´æ–°
        function startDataUpdate() {
            // æ¯100msæ›´æ–°ä¸€æ¬¡æ˜¾ç¤º
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                updateRankingDisplay();
            }, 100);
        }
        
        // æ›´æ–°ç©å®¶æ•°æ®
        function updatePlayersData(data) {
            if (data && data.users) {
                // å¦‚æœæ¥æ”¶åˆ°ç©ºçš„ç”¨æˆ·æ•°æ®ï¼Œæ¸…ç©ºæœ¬åœ°æ•°æ®
                if (Object.keys(data.users).length === 0) {
                    playersData = {};
                    return;
                }
                
                Object.keys(data.users).forEach(uid => {
                    const userData = data.users[uid];
                    playersData[uid] = {
                        uid: uid,
                        totalDamage: userData.totalDamage || 0,
                        skills: userData.skills || [],
                        realtimeDps: userData.realtimeDps || 0
                    };
                });
            }
        }
        
        // è·å–èŒä¸šåç§°
        function getRoleNameBySkills(skills) {
            if (!skills || !Array.isArray(skills) || skills.length === 0) {
                return 'æœªçŸ¥';
            }
            
            // éå†æŠ€èƒ½åˆ—è¡¨ï¼Œæ‰¾åˆ°åŒ¹é…çš„èŒä¸š
            for (const skill of skills) {
                switch (skill) {
                    case 1241:
                        return 'å°„çº¿';
                    case 55302:
                        return 'åå¥';
                    case 20301:
                        return 'æ„ˆåˆ';
                    case 1518:
                        return 'æƒ©æˆ’';
                    case 2306:
                        return 'ç‹‚éŸ³';
                    case 120902:
                        return 'å†°çŸ›';
                    case 1714:
                        return 'å±…åˆ';
                    case 44701:
                        return 'æœˆåˆƒ';
                    case 220112:
                    case 2203622:
                        return 'é¹°å¼“';
                    case 1700827:
                        return 'ç‹¼å¼“';
                    case 1419:
                        return 'ç©ºæª';
                    case 1418:
                        return 'é‡è£…';
                    case 2405:
                        return 'é˜²ç›¾';
                    case 2406:
                        return 'å…‰ç›¾';
                    case 199902:
                        return 'å²©ç›¾';
                    default:
                        continue;
                }
            }
            
            return 'æœªçŸ¥';
        }
        
        // æ ¼å¼åŒ–æ•°å­—
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
        
        // æ›´æ–°æ’è¡Œæ¦œæ˜¾ç¤º
        function updateRankingDisplay() {
            if (!rankingList) return;
            
            // è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰æ€»ä¼¤å®³æ’åº
            const sortedPlayers = Object.values(playersData)
                .filter(player => player.totalDamage > 0)
                .sort((a, b) => b.totalDamage - a.totalDamage);
            
            // ç”Ÿæˆæ•°æ®å“ˆå¸Œå€¼ç”¨äºæ£€æµ‹å˜åŒ–ï¼ˆåŒ…å«å®æ—¶DPSï¼‰
            const currentHash = JSON.stringify(sortedPlayers.map(p => ({
                uid: p.uid,
                totalDamage: p.totalDamage,
                skills: p.skills,
                realtimeDps: p.realtimeDps
            })));
            
            // å¦‚æœæ•°æ®æ²¡æœ‰å˜åŒ–ï¼Œä¸æ›´æ–°DOM
            if (currentHash === lastRankingHash) {
                return;
            }
            
            const isFirstLoad = lastRankingHash === '';
            
            // æ£€æµ‹æ–°ç©å®¶å’Œæ’åå˜åŒ–
            const currentPlayerRanks = {};
            const newPlayers = new Set();
            const rankChangedPlayers = new Set();
            
            sortedPlayers.forEach((player, index) => {
                const rank = index + 1;
                currentPlayerRanks[player.uid] = rank;
                
                if (!lastPlayerRanks[player.uid]) {
                    // æ–°ç©å®¶
                    newPlayers.add(player.uid);
                } else if (lastPlayerRanks[player.uid] !== rank) {
                    // æ’åå˜åŒ–çš„ç©å®¶
                    rankChangedPlayers.add(player.uid);
                }
            });
            
            lastRankingHash = currentHash;
            lastPlayerRanks = currentPlayerRanks;
            
            if (sortedPlayers.length === 0) {
                rankingList.innerHTML = '<div class="no-data">æš‚æ— æ•°æ®</div>';
                return;
            }
            
            // æ™ºèƒ½æ˜¾ç¤ºé€»è¾‘ï¼šåªæ˜¾ç¤º11é¡¹
            let displayPlayers = [];
            let currentPlayerUid = null;
            
            // è·å–å½“å‰ç©å®¶UIDï¼ˆä»main.jsä¼ é€’è¿‡æ¥ï¼‰
            if (window.currentPlayerUid) {
                currentPlayerUid = window.currentPlayerUid;
            }
            
            if (currentPlayerUid) {
                // æ‰¾åˆ°å½“å‰ç©å®¶çš„æ’å
                const currentPlayerIndex = sortedPlayers.findIndex(p => p.uid === currentPlayerUid);
                
                if (currentPlayerIndex !== -1 && currentPlayerIndex < 11) {
                    // ç”¨æˆ·åœ¨å‰11åï¼Œæ˜¾ç¤ºå‰11å
                    displayPlayers = sortedPlayers.slice(0, 11);
                } else if (currentPlayerIndex !== -1 && currentPlayerIndex >= 11) {
                    // ç”¨æˆ·åœ¨11åä¹‹åï¼Œæ˜¾ç¤ºå‰10å + ç”¨æˆ·
                    displayPlayers = [
                        ...sortedPlayers.slice(0, 10),
                        sortedPlayers[currentPlayerIndex]
                    ];
                } else {
                    // æ‰¾ä¸åˆ°å½“å‰ç”¨æˆ·ï¼Œæ˜¾ç¤ºå‰11å
                    displayPlayers = sortedPlayers.slice(0, 11);
                }
            } else {
                // æ²¡æœ‰å½“å‰ç”¨æˆ·ä¿¡æ¯ï¼Œæ˜¾ç¤ºå‰11å
                displayPlayers = sortedPlayers.slice(0, 11);
            }
            
            // è·å–æœ€é«˜ä¼¤å®³ä½œä¸º100%åŸºå‡†
            const maxDamage = sortedPlayers[0].totalDamage;
            
            // ç”Ÿæˆæ’è¡Œæ¦œHTML
            const html = displayPlayers.map((player) => {
                const percentage = (player.totalDamage / maxDamage) * 100;
                const roleName = getRoleNameBySkills(player.skills);
                const actualRank = sortedPlayers.findIndex(p => p.uid === player.uid) + 1;
                const isCurrentPlayer = currentPlayerUid && player.uid === currentPlayerUid;
                
                // å†³å®šæ˜¯å¦æ·»åŠ åŠ¨ç”»ç±»
                let animationClass = '';
                if (isFirstLoad || newPlayers.has(player.uid) || rankChangedPlayers.has(player.uid)) {
                    animationClass = ' initial-load';
                }
                
                // ä¸ºå½“å‰ç©å®¶æ·»åŠ ç‰¹æ®Šæ ‡è¯†ç±»ï¼Œä½†ä¸æ·»åŠ å‘å…‰æ•ˆæœ
                let playerClass = '';
                if (isCurrentPlayer) {
                    playerClass = ' current-player';
                }
                
                return `
                    <div class="ranking-item${animationClass}${playerClass}" data-rank="${actualRank}">
                        <div class="ranking-info">
                            <span class="rank-number">#${actualRank}</span>
                            <span class="player-role">${roleName}</span>
                            <span class="player-uid">${player.uid}</span>
                            <span class="damage-value">${formatNumber(player.totalDamage)} (${formatNumber(player.realtimeDps)}/s)</span>
                        </div>

                        <div class="damage-bar">
                            <div class="damage-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            rankingList.innerHTML = html;
            
            // è‡ªåŠ¨è°ƒæ•´çª—å£å¤§å°
            adjustWindowSize();
        }
        
        // åŠ¨æ€è°ƒæ•´çª—å£å¤§å°
        function adjustWindowSize() {
            setTimeout(() => {
                // è®¡ç®—å®é™…æ˜¾ç¤ºçš„æ¡ç›®æ•°é‡
                const rankingItems = document.querySelectorAll('.ranking-item');
                const itemCount = rankingItems.length;
                
                // åŸºç¡€é«˜åº¦ï¼šå¤´éƒ¨åŒºåŸŸçº¦60px + å†…è¾¹è·çº¦32px
                const baseHeight = 92;
                // æ¯ä¸ªæ¡ç›®çš„é«˜åº¦ï¼šmin-height 45px + padding 16px = 61px
                const itemHeight = 61;
                // è®¡ç®—æ€»é«˜åº¦ï¼Œæœ€å°‘æ˜¾ç¤º1ä¸ªæ¡ç›®çš„é«˜åº¦
                const totalHeight = baseHeight + Math.max(1, itemCount) * itemHeight;
                
                ipcRenderer.invoke('ranking-overlay-resize', {
                    width: 300,
                    height: totalHeight
                });
            }, 50);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initializeRankingOverlay);
        
        // çª—å£å…³é—­æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>