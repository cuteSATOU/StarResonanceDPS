<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPS排行榜</title>
    <link rel="stylesheet" href="dps-ranking-overlay.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="ranking-overlay-container">
        <!-- 悬浮窗头部（可拖拽） -->
        <div class="ranking-header" id="rankingHeader">
            <div class="ranking-title">
                <span class="ranking-icon">⚔️</span>
                <span class="title-text">DPS排行榜</span>
            </div>
            <div class="ranking-controls">
                <button class="ranking-control-btn pin-btn" id="pinBtn" title="切换置顶">
                    <span>📌</span>
                </button>
                <button class="ranking-control-btn close-btn" id="closeBtn" title="关闭">
                    <span>✕</span>
                </button>
            </div>
        </div>

        <!-- DPS排行榜内容 -->
        <div class="ranking-content">
            <div class="ranking-list" id="rankingList">
                <!-- 动态生成的排行榜项目 -->
            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');
        
        let isPinned = true;
        let updateInterval;
        let playersData = {};
        let lastRankingHash = '';
        let lastPlayerRanks = {}; // 记录上次的玩家排名
        
        // 当前玩家UID
        window.currentPlayerUid = null;
        
        // DOM元素
        let rankingList, pinBtn, closeBtn;
        
        // 初始化
        function initializeRankingOverlay() {
            // 获取DOM元素
            rankingList = document.getElementById('rankingList');
            pinBtn = document.getElementById('pinBtn');
            closeBtn = document.getElementById('closeBtn');
            
            bindEvents();
            updatePinButton();
            startDataUpdate();
        }
        
        // 绑定事件
        function bindEvents() {
            // 置顶按钮
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    isPinned = !isPinned;
                    ipcRenderer.invoke('ranking-overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            }
            
            // 关闭按钮
            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    ipcRenderer.invoke('ranking-overlay-close');
                });
            }
            
            // 全局鼠标移动监听 - 动态控制鼠标穿透
            let isMouseOverHeader = false;
            
            document.addEventListener('mousemove', (event) => {
                const rankingHeader = document.getElementById('rankingHeader');
                if (rankingHeader) {
                    const headerRect = rankingHeader.getBoundingClientRect();
                    const mouseInHeader = event.clientX >= headerRect.left && 
                                        event.clientX <= headerRect.right && 
                                        event.clientY >= headerRect.top && 
                                        event.clientY <= headerRect.bottom;
                    
                    if (mouseInHeader && !isMouseOverHeader) {
                        // 鼠标进入标题栏区域
                        isMouseOverHeader = true;
                        ipcRenderer.invoke('ranking-overlay-set-ignore-mouse-events', false);
                    } else if (!mouseInHeader && isMouseOverHeader) {
                        // 鼠标离开标题栏区域
                        isMouseOverHeader = false;
                        ipcRenderer.invoke('ranking-overlay-set-ignore-mouse-events', true);
                    }
                }
            });
            
            // 初始设置为穿透模式
            setTimeout(() => {
                ipcRenderer.invoke('ranking-overlay-set-ignore-mouse-events', true);
            }, 100);
            
            // 接收统计数据更新
            ipcRenderer.on('stats-updated', (event, data) => {
                updatePlayersData(data);
                updateRankingDisplay();
            });
            
            // 接收清空数据事件
            ipcRenderer.on('stats-cleared', () => {
                playersData = {};
                lastRankingHash = ''; // 重置哈希值以确保DOM更新
                lastPlayerRanks = {}; // 重置玩家排名记录
                updateRankingDisplay();
            });
            
            // 接收当前玩家UID更新
            ipcRenderer.on('player-uid-updated', (event, uid) => {
                window.currentPlayerUid = uid;
                console.log('DPS排行榜收到玩家UID更新:', uid);
                updateRankingDisplay(); // 重新渲染排行榜
            });
        }
        
        // 更新置顶按钮状态
        function updatePinButton() {
            if (pinBtn) {
                if (isPinned) {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = '点击取消置顶';
                } else {
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = '点击置顶显示';
                }
            }
        }
        
        // 开始数据更新
        function startDataUpdate() {
            // 每100ms更新一次显示
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                updateRankingDisplay();
            }, 100);
        }
        
        // 更新玩家数据
        function updatePlayersData(data) {
            if (data && data.users) {
                // 如果接收到空的用户数据，清空本地数据
                if (Object.keys(data.users).length === 0) {
                    playersData = {};
                    return;
                }
                
                Object.keys(data.users).forEach(uid => {
                    const userData = data.users[uid];
                    playersData[uid] = {
                        uid: uid,
                        totalDamage: userData.totalDamage || 0,
                        skills: userData.skills || [],
                        realtimeDps: userData.realtimeDps || 0,
                        displayName: userData.displayName || uid,
                        playerFightPoint: userData.playerFightPoint || 0
                    };
                });
            }
        }
        
        // 获取职业名称
        function getRoleNameBySkills(skills) {
            if (!skills || !Array.isArray(skills) || skills.length === 0) {
                return '未知';
            }
            
            // 遍历技能列表，找到匹配的职业
            for (const skill of skills) {
                switch (skill) {
                    case 1241:
                        return '射线';
                    case 55302:
                        return '协奏';
                    case 20301:
                        return '愈合';
                    case 1518:
                        return '惩戒';
                    case 2306:
                        return '狂音';
                    case 120902:
                        return '冰矛';
                    case 1714:
                        return '居合';
                    case 44701:
                        return '月刃';
                    case 220112:
                    case 2203622:
                        return '鹰弓';
                    case 1700827:
                        return '狼弓';
                    case 1419:
                        return '空枪';
                    case 1418:
                        return '重装';
                    case 2405:
                        return '防盾';
                    case 2406:
                        return '光盾';
                    case 199902:
                        return '岩盾';
                    default:
                        continue;
                }
            }
            
            return '未知';
        }
        
        // 格式化数字
        function formatNumber(num) {
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }
        
        // 更新排行榜显示
        function updateRankingDisplay() {
            if (!rankingList) return;
            
            // 转换为数组并按总伤害排序
            const sortedPlayers = Object.values(playersData)
                .filter(player => player.totalDamage > 0)
                .sort((a, b) => b.totalDamage - a.totalDamage);
            
            // 生成数据哈希值用于检测变化（包含实时DPS）
            const currentHash = JSON.stringify(sortedPlayers.map(p => ({
                uid: p.uid,
                totalDamage: p.totalDamage,
                skills: p.skills,
                realtimeDps: p.realtimeDps
            })));
            
            // 如果数据没有变化，不更新DOM
            if (currentHash === lastRankingHash) {
                return;
            }
            
            const isFirstLoad = lastRankingHash === '';
            
            // 检测新玩家和排名变化
            const currentPlayerRanks = {};
            const newPlayers = new Set();
            const rankChangedPlayers = new Set();
            
            sortedPlayers.forEach((player, index) => {
                const rank = index + 1;
                currentPlayerRanks[player.uid] = rank;
                
                if (!lastPlayerRanks[player.uid]) {
                    // 新玩家
                    newPlayers.add(player.uid);
                } else if (lastPlayerRanks[player.uid] !== rank) {
                    // 排名变化的玩家
                    rankChangedPlayers.add(player.uid);
                }
            });
            
            lastRankingHash = currentHash;
            lastPlayerRanks = currentPlayerRanks;
            
            if (sortedPlayers.length === 0) {
                rankingList.innerHTML = '<div class="no-data">暂无数据</div>';
                return;
            }
            
            // 智能显示逻辑：只显示11项
            let displayPlayers = [];
            let currentPlayerUid = null;
            
            // 获取当前玩家UID（从main.js传递过来）
            if (window.currentPlayerUid) {
                currentPlayerUid = window.currentPlayerUid;
            }
            
            if (currentPlayerUid) {
                // 找到当前玩家的排名
                const currentPlayerIndex = sortedPlayers.findIndex(p => p.uid === currentPlayerUid);
                
                if (currentPlayerIndex !== -1 && currentPlayerIndex < 11) {
                    // 用户在前11名，显示前11名
                    displayPlayers = sortedPlayers.slice(0, 11);
                } else if (currentPlayerIndex !== -1 && currentPlayerIndex >= 11) {
                    // 用户在11名之后，显示前10名 + 用户
                    displayPlayers = [
                        ...sortedPlayers.slice(0, 10),
                        sortedPlayers[currentPlayerIndex]
                    ];
                } else {
                    // 找不到当前用户，显示前11名
                    displayPlayers = sortedPlayers.slice(0, 11);
                }
            } else {
                // 没有当前用户信息，显示前11名
                displayPlayers = sortedPlayers.slice(0, 11);
            }
            
            // 获取最高伤害作为100%基准
            const maxDamage = sortedPlayers[0].totalDamage;
            
            // 生成排行榜HTML
            const html = displayPlayers.map((player) => {
                const percentage = (player.totalDamage / maxDamage) * 100;
                const roleName = getRoleNameBySkills(player.skills);
                const actualRank = sortedPlayers.findIndex(p => p.uid === player.uid) + 1;
                const isCurrentPlayer = currentPlayerUid && player.uid === currentPlayerUid;
                
                // 决定是否添加动画类
                let animationClass = '';
                if (isFirstLoad || newPlayers.has(player.uid) || rankChangedPlayers.has(player.uid)) {
                    animationClass = ' initial-load';
                }
                
                // 为当前玩家添加特殊标识类，但不添加发光效果
                let playerClass = '';
                if (isCurrentPlayer) {
                    playerClass = ' current-player';
                }
                
                const fightPointText = player.playerFightPoint > 0 ? ` | ${formatNumber(player.playerFightPoint)}` : '';
                
                return `
                    <div class="ranking-item${animationClass}${playerClass}" data-rank="${actualRank}">
                        <div class="ranking-info">
                            <span class="rank-number">#${actualRank}</span>
                            <span class="player-role">${roleName}${fightPointText}</span>
                            <span class="player-uid" title="UID: ${player.uid}">${player.displayName}</span>
                            <span class="damage-value">${formatNumber(player.totalDamage)} (${formatNumber(player.realtimeDps)}/s)</span>
                        </div>

                        <div class="damage-bar">
                            <div class="damage-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            rankingList.innerHTML = html;
            
            // 自动调整窗口大小
            adjustWindowSize();
        }
        
        // 动态调整窗口大小
        function adjustWindowSize() {
            setTimeout(() => {
                const container = document.querySelector('.ranking-overlay-container');
                if (!container) return;
                
                // 获取容器的实际内容高度
                const containerRect = container.getBoundingClientRect();
                const actualHeight = container.scrollHeight;
                
                // 获取当前窗口大小
                const currentWidth = containerRect.width || 350;
                
                // 设置最小高度（头部 + 至少一个条目的空间）
                const minHeight = 145;
                
                // 计算最终高度，确保不小于最小高度
                const finalHeight = Math.max(minHeight, actualHeight);
                
                // 调整窗口大小
                ipcRenderer.invoke('ranking-overlay-resize', {
                    width: Math.max(350, currentWidth),
                    height: finalHeight
                });
            }, 100); // 增加延迟确保DOM完全渲染
        }
        
        // 监听窗口大小变化
        function setupResizeObserver() {
            if (typeof ResizeObserver !== 'undefined') {
                const container = document.querySelector('.ranking-overlay-container');
                if (container) {
                    const resizeObserver = new ResizeObserver(entries => {
                        // 当容器大小发生变化时，调整窗口大小
                        adjustWindowSize();
                    });
                    resizeObserver.observe(container);
                }
            }
        }
        
        // 监听内容变化
        function setupMutationObserver() {
            const rankingList = document.getElementById('rankingList');
            if (rankingList) {
                const mutationObserver = new MutationObserver(mutations => {
                    // 当排行榜内容发生变化时，调整窗口大小
                    adjustWindowSize();
                });
                mutationObserver.observe(rankingList, {
                    childList: true,
                    subtree: true,
                    attributes: true
                });
            }
        }
        
        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', () => {
            initializeRankingOverlay();
            setupResizeObserver();
            setupMutationObserver();
        });
        
        // 窗口关闭时清理
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
        });
    </script>
</body>
</html>