<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPS悬浮窗</title>
    <link rel="stylesheet" href="overlay-window.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="overlay-container">
        <!-- 悬浮窗头部（可拖拽） -->
        <div class="overlay-header" id="overlayHeader">
            <div class="overlay-title">
                <span class="overlay-icon">⚡</span>
                <span class="title-text">DPS监控</span>
            </div>
            <div class="overlay-controls">
                <button class="overlay-control-btn pin-btn" id="pinBtn" title="切换置顶">
                    <span>📌</span>
                </button>
                <button class="overlay-control-btn settings-btn" id="settingsBtn" title="设置">
                    <span>⚙️</span>
                </button>
                <button class="overlay-control-btn minimize-btn" id="minimizeBtn" title="最小化">
                    <span>–</span>
                </button>
                <button class="overlay-control-btn close-btn" id="closeBtn" title="关闭">
                    <span>✕</span>
                </button>
            </div>
        </div>

        <!-- DPS数据显示区域 -->
        <div class="overlay-content">
            <!-- 主要DPS指标 -->
            <div class="dps-main">
                <div class="dps-item primary">
                    <div class="dps-label">实时DPS</div>
                    <div class="dps-value" id="realtimeDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">峰值DPS</div>
                    <div class="dps-value" id="maxDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">平均DPS</div>
                    <div class="dps-value" id="avgDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgDpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- 治疗数据显示区域 -->
            <div class="hps-main">
                <div class="dps-item primary">
                    <div class="dps-label">实时HPS</div>
                    <div class="dps-value" id="realtimeHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">峰值HPS</div>
                    <div class="dps-value" id="maxHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">平均HPS</div>
                    <div class="dps-value" id="avgHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgHpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- 详细统计（可折叠） -->
            <div class="dps-details" id="dpsDetails">
                <div class="details-header" id="detailsToggle">
                    <span class="details-title">详细统计</span>
                    <span class="details-arrow">▼</span>
                </div>
                <div class="details-content" id="detailsContent">
                    <div class="detail-row">
                        <span class="detail-label">总伤害</span>
                        <span class="detail-value" id="totalDamage">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">总治疗</span>
                        <span class="detail-value" id="totalHealing">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">暴击率</span>
                        <span class="detail-value" id="critRate">0%</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">攻击次数</span>
                        <span class="detail-value" id="attackCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">治疗次数</span>
                        <span class="detail-value" id="healingCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">玩家UID</span>
                        <span class="detail-value" id="playerUid">未检测</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 设置面板（隐藏） -->
        <div class="overlay-settings" id="overlaySettings" style="display: none;">
            <div class="settings-header">
                <h4>悬浮窗设置</h4>
                <button class="close-settings-btn" id="closeSettingsBtn">✕</button>
            </div>
            <div class="settings-content">
                <div class="setting-item">
                    <label>透明度</label>
                    <input type="range" id="opacitySlider" min="30" max="100" value="90" step="10">
                    <span id="opacityValue">90%</span>
                </div>
                <div class="setting-item">
                    <label>更新频率</label>
                    <select id="updateFrequency">
                        <option value="100">100ms (流畅)</option>
                        <option value="250" selected>250ms (平衡)</option>
                        <option value="500">500ms (节能)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDetailsDefault" checked>
                        <span class="checkbox-custom"></span>
                        默认显示详细统计
                    </label>
                </div>

                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="hideHpsDisplay">
                        <span class="checkbox-custom"></span>
                        隐藏HPS显示
                    </label>
                </div>

            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let statsData = {};
        let detailsExpanded = true;
        let updateInterval = null;
        let updateFreency = 500; // 默认降低更新频率以节省性能
        let opacity = 90;
        let isPinned = true;
        let hideHpsDisplay = false;
        let selfOnlyMode = false;

        // DOM元素
        let realtimeDps, maxDps, avgDps, totalDamage, critRate, attackCount, playerUid;
        let realtimeHps, maxHps, avgHps, totalHealing, healingCount;
        let realtimeDpsBar, maxDpsBar, avgDpsBar;
        let realtimeHpsBar, maxHpsBar, avgHpsBar;
        let pinBtn, settingsBtn, minimizeBtn, closeBtn;
        let detailsToggle, detailsContent;
        let overlaySettings, closeSettingsBtn, opacitySlider, opacityValue, updateFrequencySelect;
        let showDetailsDefaultCheckbox, hideHpsDisplayCheckbox;

        // 初始化
        function initializeOverlay() {
            // 获取DOM元素
            realtimeDps = document.getElementById('realtimeDps');
            maxDps = document.getElementById('maxDps');
            avgDps = document.getElementById('avgDps');
            totalDamage = document.getElementById('totalDamage');
            realtimeHps = document.getElementById('realtimeHps');
            maxHps = document.getElementById('maxHps');
            avgHps = document.getElementById('avgHps');
            totalHealing = document.getElementById('totalHealing');
            healingCount = document.getElementById('healingCount');
            critRate = document.getElementById('critRate');
            attackCount = document.getElementById('attackCount');
            playerUid = document.getElementById('playerUid');
            
            // 调试：检查DOM元素是否正确获取
            console.log('悬浮窗DOM元素初始化:', {
                playerUid: playerUid,
                playerUidExists: !!playerUid
            });
            
            realtimeDpsBar = document.getElementById('realtimeDpsBar');
            maxDpsBar = document.getElementById('maxDpsBar');
            avgDpsBar = document.getElementById('avgDpsBar');
            realtimeHpsBar = document.getElementById('realtimeHpsBar');
            maxHpsBar = document.getElementById('maxHpsBar');
            avgHpsBar = document.getElementById('avgHpsBar');
            
            pinBtn = document.getElementById('pinBtn');
            settingsBtn = document.getElementById('settingsBtn');
            minimizeBtn = document.getElementById('minimizeBtn');
            closeBtn = document.getElementById('closeBtn');
            detailsToggle = document.getElementById('detailsToggle');
            detailsContent = document.getElementById('detailsContent');
            
            overlaySettings = document.getElementById('overlaySettings');
            closeSettingsBtn = document.getElementById('closeSettingsBtn');
            opacitySlider = document.getElementById('opacitySlider');
            opacityValue = document.getElementById('opacityValue');
            updateFrequencySelect = document.getElementById('updateFrequency');
            showDetailsDefaultCheckbox = document.getElementById('showDetailsDefault');
            hideHpsDisplayCheckbox = document.getElementById('hideHpsDisplay');

            bindEvents();
            loadSettings();
            updatePinButton();
            
            // 确保详细统计默认展开
            if (detailsContent) {
                detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                const arrow = document.querySelector('.details-arrow');
                if (arrow) {
                    arrow.textContent = detailsExpanded ? '▼' : '▶';
                }
                console.log('详细统计展开状态:', detailsExpanded);
            }
            
            startDataUpdate();
            
            // 初始化时调整窗口大小
            setTimeout(() => {
                adjustWindowSize();
            }, 100);
        }

        // 绑定事件
        function bindEvents() {
            console.log('开始绑定事件，检查DOM元素:', {
                pinBtn: !!pinBtn,
                settingsBtn: !!settingsBtn,
                minimizeBtn: !!minimizeBtn,
                closeBtn: !!closeBtn,
                detailsToggle: !!detailsToggle,
                closeSettingsBtn: !!closeSettingsBtn,
                opacitySlider: !!opacitySlider,
                updateFrequencySelect: !!updateFrequencySelect,
                showDetailsDefaultCheckbox: !!showDetailsDefaultCheckbox
            });

            // 置顶按钮
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    console.log('置顶按钮被点击');
                    isPinned = !isPinned;
                    ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            } else {
                console.error('置顶按钮元素未找到');
            }

            // 控制按钮
            if (settingsBtn && overlaySettings) {
                settingsBtn.addEventListener('click', () => {
                    console.log('设置按钮被点击');
                    overlaySettings.style.display = overlaySettings.style.display === 'none' ? 'block' : 'none';
                });
            } else {
                console.error('设置按钮或设置面板元素未找到');
            }

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', () => {
                    console.log('最小化按钮被点击');
                    ipcRenderer.invoke('overlay-minimize');
                });
            } else {
                console.error('最小化按钮元素未找到');
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    console.log('关闭按钮被点击');
                    ipcRenderer.invoke('overlay-close');
                });
            } else {
                console.error('关闭按钮元素未找到');
            }

            // 详细统计折叠
            if (detailsToggle && detailsContent) {
                detailsToggle.addEventListener('click', () => {
                    console.log('详细统计折叠按钮被点击');
                    detailsExpanded = !detailsExpanded;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? '▼' : '▶';
                    }
                    adjustWindowSize();
                });
            } else {
                console.error('详细统计折叠按钮或内容元素未找到');
            }

            // 设置面板
            if (closeSettingsBtn && overlaySettings) {
                closeSettingsBtn.addEventListener('click', () => {
                    console.log('关闭设置按钮被点击');
                    overlaySettings.style.display = 'none';
                });
            } else {
                console.error('关闭设置按钮或设置面板元素未找到');
            }

            // 透明度设置
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', (e) => {
                    console.log('透明度滑块被调整:', e.target.value);
                    opacity = parseInt(e.target.value);
                    opacityValue.textContent = opacity + '%';
                    document.body.style.opacity = opacity / 100;
                    saveSettings();
                });
            } else {
                console.error('透明度滑块或显示元素未找到');
            }

            // 更新频率设置
            if (updateFrequencySelect) {
                updateFrequencySelect.addEventListener('change', (e) => {
                    console.log('更新频率被修改:', e.target.value);
                    updateFreency = parseInt(e.target.value);
                    restartDataUpdate();
                    saveSettings();
                });
            } else {
                console.error('更新频率选择元素未找到');
            }

            // 默认显示详细统计
            if (showDetailsDefaultCheckbox && detailsContent) {
                showDetailsDefaultCheckbox.addEventListener('change', (e) => {
                    console.log('默认显示详细统计复选框被修改:', e.target.checked);
                    detailsExpanded = e.target.checked;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? '▼' : '▶';
                    }
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('默认显示详细统计复选框或详细内容元素未找到');
            }

            // 隐藏HPS显示
            if (hideHpsDisplayCheckbox) {
                hideHpsDisplayCheckbox.addEventListener('change', (e) => {
                    console.log('隐藏HPS显示复选框被修改:', e.target.checked);
                    hideHpsDisplay = e.target.checked;
                    toggleHpsDisplay();
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('隐藏HPS显示复选框未找到');
            }



            // 原来的数据更新监听器已移到下面，添加了调试信息

            // 接收玩家UID更新
            ipcRenderer.on('player-uid-updated', (event, uid) => {
                console.log('悬浮窗收到UID更新事件:', {
                    uid: uid,
                    uidType: typeof uid,
                    playerUidElement: playerUid,
                    playerUidExists: !!playerUid,
                    timestamp: new Date().toISOString()
                });
                
                if (playerUid) {
                    const displayUid = uid || '未检测';
                    playerUid.textContent = displayUid;
                    console.log('UID已更新到悬浮窗，当前显示:', displayUid);
                    
                    // 强制触发DOM更新
                    playerUid.style.color = uid ? '#4CAF50' : '#f44336';
                } else {
                    console.error('playerUid DOM元素不存在！无法更新UID显示');
                }
            });

            // 接收"仅自己"模式切换
            ipcRenderer.on('self-only-mode-changed', (event, enabled) => {
                console.log('悬浮窗收到"仅自己"模式切换:', enabled);
                selfOnlyMode = enabled;
                console.log('悬浮窗"仅自己"模式状态已更新为:', selfOnlyMode);
            });

            // 接收数据更新
            ipcRenderer.on('stats-updated', (event, data) => {
                console.log('悬浮窗收到数据更新:', {
                    selfOnlyMode: selfOnlyMode,
                    dataKeys: Object.keys(data),
                    dataCount: Object.keys(data).length
                });
                statsData = data;
                updateDpsDisplay();
            });
        }

        // 开始数据更新
        function startDataUpdate() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                ipcRenderer.invoke('get-stats-data').then(data => {
                    if (data) {
                        statsData = data;
                        updateDpsDisplay();
                    }
                });
            }, updateFreency);

            // 获取当前玩家UID
            console.log('悬浮窗开始获取当前UID...');
            ipcRenderer.invoke('get-player-uid').then(uid => {
                console.log('悬浮窗get-player-uid响应:', {
                    uid: uid,
                    hasUid: !!uid,
                    playerUidElement: playerUid,
                    playerUidExists: !!playerUid
                });
                
                if (playerUid) {
                    const displayUid = uid || '未检测';
                    playerUid.textContent = displayUid;
                    playerUid.style.color = uid ? '#4CAF50' : '#f44336';
                    console.log('悬浮窗主动获取UID成功，设置为:', displayUid);
                } else {
                    console.error('playerUid DOM元素不存在！');
                }
            }).catch(err => {
                console.error('获取玩家UID失败:', err);
                if (playerUid) {
                    playerUid.textContent = '获取失败';
                    playerUid.style.color = '#f44336';
                }
            });
        }

        // 重启数据更新
        function restartDataUpdate() {
            startDataUpdate();
        }

        // 自动调整窗口大小
        function adjustWindowSize() {
            // 等待DOM更新完成
            setTimeout(() => {
                const container = document.querySelector('.overlay-container');
                if (container) {
                    const rect = container.getBoundingClientRect();
                    const newWidth = Math.max(280, Math.min(500, rect.width + 20)); // 添加一些边距
                    const newHeight = Math.max(200, Math.min(800, rect.height + 20));
                    
                    ipcRenderer.invoke('overlay-resize', {
                        width: Math.ceil(newWidth),
                        height: Math.ceil(newHeight)
                    });
                }
            }, 50);
        }

        // 切换HPS显示
        function toggleHpsDisplay() {
            console.log('切换HPS显示状态:', hideHpsDisplay);
            
            // 隐藏整个HPS主显示区域
            const hpsMain = document.querySelector('.hps-main');
            if (hpsMain) {
                hpsMain.style.display = hideHpsDisplay ? 'none' : '';
                console.log('HPS主区域显示状态:', hpsMain.style.display);
            } else {
                console.error('未找到.hps-main元素');
            }
            
            // 隐藏详细统计中的HPS相关项目
            const totalHealingRow = document.getElementById('totalHealing')?.closest('.detail-row');
            const healingCountRow = document.getElementById('healingCount')?.closest('.detail-row');
            
            if (totalHealingRow) {
                totalHealingRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('总治疗行显示状态:', totalHealingRow.style.display);
            } else {
                console.error('未找到总治疗行元素');
            }
            
            if (healingCountRow) {
                healingCountRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('治疗次数行显示状态:', healingCountRow.style.display);
            } else {
                console.error('未找到治疗次数行元素');
            }
        }

        // 更新DPS显示
        function updateDpsDisplay() {
            const userIds = Object.keys(statsData);
            
            if (userIds.length === 0) {
                // 无数据时显示0
                realtimeDps.textContent = '0';
                maxDps.textContent = '0';
                avgDps.textContent = '0';
                totalDamage.textContent = '0';
                realtimeHps.textContent = '0';
                maxHps.textContent = '0';
                avgHps.textContent = '0';
                totalHealing.textContent = '0';
                healingCount.textContent = '0';
                critRate.textContent = '0%';
                attackCount.textContent = '0';
                updateProgressBars(0, 0, 0, 0, 0, 0);
                adjustWindowSize();
                return;
            }

            // 计算总体数据
            let totalRealtimeDpsValue = 0;
            let totalMaxDpsValue = 0;
            let totalAvgDpsValue = 0;
            let totalDamageValue = 0;
            let totalRealtimeHpsValue = 0;
            let totalMaxHpsValue = 0;
            let totalAvgHpsValue = 0;
            let totalHealingValue = 0;
            let totalHealingCountValue = 0;
            let totalCritCount = 0;
            let totalAttackCount = 0;

            for (const uid of userIds) {
                const userData = statsData[uid];
                totalRealtimeDpsValue += userData.realtime_dps || 0;
                totalMaxDpsValue = Math.max(totalMaxDpsValue, userData.realtime_dps_max || 0);
                totalAvgDpsValue += userData.total_dps || 0;
                totalDamageValue += userData.total_damage.total || 0;
                totalRealtimeHpsValue += userData.realtime_hps || 0;
                totalMaxHpsValue = Math.max(totalMaxHpsValue, userData.realtime_hps_max || 0);
                totalAvgHpsValue += userData.total_hps || 0;
                totalHealingValue += userData.total_healing ? userData.total_healing.total || 0 : 0;
                totalHealingCountValue += userData.healing_count ? userData.healing_count.total || 0 : 0;
                totalCritCount += userData.total_count.critical || 0;
                totalAttackCount += userData.total_count.total || 0;
            }

            if (userIds.length > 0) {
                totalAvgDpsValue = totalAvgDpsValue / userIds.length;
                totalAvgHpsValue = totalAvgHpsValue / userIds.length;
            }

            const critRateValue = totalAttackCount > 0 ? (totalCritCount / totalAttackCount) : 0;

            // 更新显示
            realtimeDps.textContent = formatNumber(totalRealtimeDpsValue);
            maxDps.textContent = formatNumber(totalMaxDpsValue);
            avgDps.textContent = formatNumber(totalAvgDpsValue);
            totalDamage.textContent = formatNumber(totalDamageValue);
            realtimeHps.textContent = formatNumber(totalRealtimeHpsValue);
            maxHps.textContent = formatNumber(totalMaxHpsValue);
            avgHps.textContent = formatNumber(totalAvgHpsValue);
            totalHealing.textContent = formatNumber(totalHealingValue);
            healingCount.textContent = totalHealingCountValue.toString();
            critRate.textContent = (critRateValue * 100).toFixed(1) + '%';
            attackCount.textContent = totalAttackCount.toString();

            // 更新进度条
            updateProgressBars(totalRealtimeDpsValue, totalMaxDpsValue, totalAvgDpsValue, totalRealtimeHpsValue, totalMaxHpsValue, totalAvgHpsValue);
            
            // 调整窗口大小
            adjustWindowSize();
        }

        // 更新进度条
        function updateProgressBars(realtime, max, avg, realtimeHps, maxHps, avgHps) {
            // DPS进度条
            const maxDpsValue = Math.max(realtime, max, avg) || 1;
            
            const realtimePercent = (realtime / maxDpsValue) * 100;
            const maxPercent = (max / maxDpsValue) * 100;
            const avgPercent = (avg / maxDpsValue) * 100;
            
            realtimeDpsBar.style.width = `${Math.min(realtimePercent, 100)}%`;
            maxDpsBar.style.width = `${Math.min(maxPercent, 100)}%`;
            avgDpsBar.style.width = `${Math.min(avgPercent, 100)}%`;
            
            // HPS进度条
            const maxHpsValue = Math.max(realtimeHps, maxHps, avgHps) || 1;
            
            const realtimeHpsPercent = (realtimeHps / maxHpsValue) * 100;
            const maxHpsPercent = (maxHps / maxHpsValue) * 100;
            const avgHpsPercent = (avgHps / maxHpsValue) * 100;
            
            if (realtimeHpsBar) realtimeHpsBar.style.width = `${Math.min(realtimeHpsPercent, 100)}%`;
            if (maxHpsBar) maxHpsBar.style.width = `${Math.min(maxHpsPercent, 100)}%`;
            if (avgHpsBar) avgHpsBar.style.width = `${Math.min(avgHpsPercent, 100)}%`;
        }

        // 格式化数字
        function formatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            } else {
                return Math.floor(num).toString();
            }
        }

        // 更新置顶按钮状态
        function updatePinButton() {
            if (pinBtn) {
                const pinIcon = pinBtn.querySelector('span');
                if (isPinned) {
                    pinIcon.textContent = '📌';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = '点击取消置顶';
                } else {
                    pinIcon.textContent = '📍';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = '点击置顶显示';
                }
            }
        }

        // 保存设置
        function saveSettings() {
            const settings = {
                opacity,
                updateFreency,
                detailsExpanded,
                isPinned,
                hideHpsDisplay
            };
            localStorage.setItem('overlaySettings', JSON.stringify(settings));
        }

        // 加载设置
        function loadSettings() {
            try {
                const settings = JSON.parse(localStorage.getItem('overlaySettings') || '{}');
                
                if (settings.opacity !== undefined) {
                    opacity = settings.opacity;
                    opacitySlider.value = opacity;
                    opacityValue.textContent = opacity + '%';
                    document.body.style.opacity = opacity / 100;
                }
                
                if (settings.updateFreency !== undefined) {
                    updateFreency = settings.updateFreency;
                    updateFrequencySelect.value = updateFreency;
                }
                
                if (settings.detailsExpanded !== undefined) {
                    detailsExpanded = settings.detailsExpanded;
                    showDetailsDefaultCheckbox.checked = detailsExpanded;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    document.querySelector('.details-arrow').textContent = detailsExpanded ? '▼' : '▶';
                }
                
                if (settings.isPinned !== undefined) {
                    isPinned = settings.isPinned;
                    ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                    updatePinButton();
                }
                
                if (settings.hideHpsDisplay !== undefined) {
                    hideHpsDisplay = settings.hideHpsDisplay;
                    hideHpsDisplayCheckbox.checked = hideHpsDisplay;
                    toggleHpsDisplay();
                }
            } catch (error) {
                console.error('加载设置失败:', error);
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', initializeOverlay);

        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            // 清理数据引用
            statsData = null;
        });
    </script>
</body>
</html>