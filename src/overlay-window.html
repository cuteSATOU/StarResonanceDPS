<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPSæ‚¬æµ®çª—</title>
    <link rel="stylesheet" href="overlay-window.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="overlay-container">
        <!-- æ‚¬æµ®çª—å¤´éƒ¨ï¼ˆå¯æ‹–æ‹½ï¼‰ -->
        <div class="overlay-header" id="overlayHeader">
            <div class="overlay-title">
                <span class="overlay-icon">âš¡</span>
                <span class="title-text">DPSç›‘æ§</span>
            </div>
            <div class="overlay-controls">
                <button class="overlay-control-btn pin-btn" id="pinBtn" title="åˆ‡æ¢ç½®é¡¶">
                    <span>ğŸ“Œ</span>
                </button>
                <button class="overlay-control-btn settings-btn" id="settingsBtn" title="è®¾ç½®">
                    <span>âš™ï¸</span>
                </button>
                <button class="overlay-control-btn minimize-btn" id="minimizeBtn" title="æœ€å°åŒ–">
                    <span>â€“</span>
                </button>
                <button class="overlay-control-btn close-btn" id="closeBtn" title="å…³é—­">
                    <span>âœ•</span>
                </button>
            </div>
        </div>

        <!-- DPSæ•°æ®æ˜¾ç¤ºåŒºåŸŸ -->
        <div class="overlay-content">
            <!-- ä¸»è¦DPSæŒ‡æ ‡ -->
            <div class="dps-main">
                <div class="dps-item primary">
                    <div class="dps-label">å®æ—¶DPS</div>
                    <div class="dps-value" id="realtimeDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">å³°å€¼DPS</div>
                    <div class="dps-value" id="maxDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">å¹³å‡DPS</div>
                    <div class="dps-value" id="avgDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgDpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- æ²»ç–—æ•°æ®æ˜¾ç¤ºåŒºåŸŸ -->
            <div class="hps-main">
                <div class="dps-item primary">
                    <div class="dps-label">å®æ—¶HPS</div>
                    <div class="dps-value" id="realtimeHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">å³°å€¼HPS</div>
                    <div class="dps-value" id="maxHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">å¹³å‡HPS</div>
                    <div class="dps-value" id="avgHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgHpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- è¯¦ç»†ç»Ÿè®¡ï¼ˆå¯æŠ˜å ï¼‰ -->
            <div class="dps-details" id="dpsDetails">
                <div class="details-header" id="detailsToggle">
                    <span class="details-title">è¯¦ç»†ç»Ÿè®¡</span>
                    <span class="details-arrow">â–¼</span>
                </div>
                <div class="details-content" id="detailsContent">
                    <div class="detail-row">
                        <span class="detail-label">æ€»ä¼¤å®³</span>
                        <span class="detail-value" id="totalDamage">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">æ€»æ²»ç–—</span>
                        <span class="detail-value" id="totalHealing">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">æš´å‡»ç‡</span>
                        <span class="detail-value" id="critRate">0%</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">æ”»å‡»æ¬¡æ•°</span>
                        <span class="detail-value" id="attackCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">æ²»ç–—æ¬¡æ•°</span>
                        <span class="detail-value" id="healingCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">ç©å®¶</span>
                        <span class="detail-value" id="playerUid">æœªæ£€æµ‹</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">æˆ˜åŠ›</span>
                        <span class="detail-value" id="playerFightPoint">æœªæ£€æµ‹</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- è®¾ç½®é¢æ¿ï¼ˆéšè—ï¼‰ -->
        <div class="overlay-settings" id="overlaySettings" style="display: none;">
            <div class="settings-header">
                <h4>æ‚¬æµ®çª—è®¾ç½®</h4>
                <button class="close-settings-btn" id="closeSettingsBtn">âœ•</button>
            </div>
            <div class="settings-content">
                <div class="setting-item">
                    <label>é€æ˜åº¦</label>
                    <input type="range" id="opacitySlider" min="30" max="100" value="90" step="10">
                    <span id="opacityValue">90%</span>
                </div>
                <div class="setting-item">
                    <label>æ›´æ–°é¢‘ç‡</label>
                    <select id="updateFrequency">
                        <option value="100">100ms (æµç•…)</option>
                        <option value="250" selected>250ms (å¹³è¡¡)</option>
                        <option value="500">500ms (èŠ‚èƒ½)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDetailsDefault" checked>
                        <span class="checkbox-custom"></span>
                        é»˜è®¤æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
                    </label>
                </div>

                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="hideHpsDisplay">
                        <span class="checkbox-custom"></span>
                        éšè—HPSæ˜¾ç¤º
                    </label>
                </div>

            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let statsData = {};
        let detailsExpanded = true;
        let updateInterval = null;
        let updateFreency = 500; // é»˜è®¤é™ä½æ›´æ–°é¢‘ç‡ä»¥èŠ‚çœæ€§èƒ½
        let opacity = 90;
        let isPinned = true;
        let hideHpsDisplay = false;
        let selfOnlyMode = false;

        // DOMå…ƒç´ 
        let realtimeDps, maxDps, avgDps, totalDamage, critRate, attackCount, playerUid, playerFightPoint;
        let realtimeHps, maxHps, avgHps, totalHealing, healingCount;
        let realtimeDpsBar, maxDpsBar, avgDpsBar;
        let realtimeHpsBar, maxHpsBar, avgHpsBar;
        let pinBtn, settingsBtn, minimizeBtn, closeBtn;
        let detailsToggle, detailsContent;
        let overlaySettings, closeSettingsBtn, opacitySlider, opacityValue, updateFrequencySelect;
        let showDetailsDefaultCheckbox, hideHpsDisplayCheckbox;

        // åˆå§‹åŒ–
        async function initializeOverlay() {
            // è·å–DOMå…ƒç´ 
            realtimeDps = document.getElementById('realtimeDps');
            maxDps = document.getElementById('maxDps');
            avgDps = document.getElementById('avgDps');
            totalDamage = document.getElementById('totalDamage');
            realtimeHps = document.getElementById('realtimeHps');
            maxHps = document.getElementById('maxHps');
            avgHps = document.getElementById('avgHps');
            totalHealing = document.getElementById('totalHealing');
            healingCount = document.getElementById('healingCount');
            critRate = document.getElementById('critRate');
            attackCount = document.getElementById('attackCount');
            playerUid = document.getElementById('playerUid');
            playerFightPoint = document.getElementById('playerFightPoint');
            
            // è°ƒè¯•ï¼šæ£€æŸ¥DOMå…ƒç´ æ˜¯å¦æ­£ç¡®è·å–
            console.log('æ‚¬æµ®çª—DOMå…ƒç´ åˆå§‹åŒ–:', {
                playerUid: playerUid,
                playerUidExists: !!playerUid
            });
            
            realtimeDpsBar = document.getElementById('realtimeDpsBar');
            maxDpsBar = document.getElementById('maxDpsBar');
            avgDpsBar = document.getElementById('avgDpsBar');
            realtimeHpsBar = document.getElementById('realtimeHpsBar');
            maxHpsBar = document.getElementById('maxHpsBar');
            avgHpsBar = document.getElementById('avgHpsBar');
            
            pinBtn = document.getElementById('pinBtn');
            settingsBtn = document.getElementById('settingsBtn');
            minimizeBtn = document.getElementById('minimizeBtn');
            closeBtn = document.getElementById('closeBtn');
            detailsToggle = document.getElementById('detailsToggle');
            detailsContent = document.getElementById('detailsContent');
            
            overlaySettings = document.getElementById('overlaySettings');
            closeSettingsBtn = document.getElementById('closeSettingsBtn');
            opacitySlider = document.getElementById('opacitySlider');
            opacityValue = document.getElementById('opacityValue');
            updateFrequencySelect = document.getElementById('updateFrequency');
            showDetailsDefaultCheckbox = document.getElementById('showDetailsDefault');
            hideHpsDisplayCheckbox = document.getElementById('hideHpsDisplay');

            bindEvents();
            await loadSettings();
            updatePinButton();
            
            // ç¡®ä¿è¯¦ç»†ç»Ÿè®¡é»˜è®¤å±•å¼€
            if (detailsContent) {
                detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                const arrow = document.querySelector('.details-arrow');
                if (arrow) {
                    arrow.textContent = detailsExpanded ? 'â–¼' : 'â–¶';
                }
                console.log('è¯¦ç»†ç»Ÿè®¡å±•å¼€çŠ¶æ€:', detailsExpanded);
            }
            
            startDataUpdate();
            
            // åˆå§‹åŒ–æ—¶è°ƒæ•´çª—å£å¤§å°
            setTimeout(() => {
                adjustWindowSize();
            }, 100);
        }

        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            console.log('å¼€å§‹ç»‘å®šäº‹ä»¶ï¼Œæ£€æŸ¥DOMå…ƒç´ :', {
                pinBtn: !!pinBtn,
                settingsBtn: !!settingsBtn,
                minimizeBtn: !!minimizeBtn,
                closeBtn: !!closeBtn,
                detailsToggle: !!detailsToggle,
                closeSettingsBtn: !!closeSettingsBtn,
                opacitySlider: !!opacitySlider,
                updateFrequencySelect: !!updateFrequencySelect,
                showDetailsDefaultCheckbox: !!showDetailsDefaultCheckbox
            });

            // ç½®é¡¶æŒ‰é’®
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    console.log('ç½®é¡¶æŒ‰é’®è¢«ç‚¹å‡»');
                    isPinned = !isPinned;
                    ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            } else {
                console.error('ç½®é¡¶æŒ‰é’®å…ƒç´ æœªæ‰¾åˆ°');
            }

            // æ§åˆ¶æŒ‰é’®
            if (settingsBtn && overlaySettings) {
                settingsBtn.addEventListener('click', () => {
                    console.log('è®¾ç½®æŒ‰é’®è¢«ç‚¹å‡»');
                    overlaySettings.style.display = overlaySettings.style.display === 'none' ? 'block' : 'none';
                });
            } else {
                console.error('è®¾ç½®æŒ‰é’®æˆ–è®¾ç½®é¢æ¿å…ƒç´ æœªæ‰¾åˆ°');
            }

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', () => {
                    console.log('æœ€å°åŒ–æŒ‰é’®è¢«ç‚¹å‡»');
                    ipcRenderer.invoke('overlay-minimize');
                });
            } else {
                console.error('æœ€å°åŒ–æŒ‰é’®å…ƒç´ æœªæ‰¾åˆ°');
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    console.log('å…³é—­æŒ‰é’®è¢«ç‚¹å‡»');
                    ipcRenderer.invoke('overlay-close');
                });
            } else {
                console.error('å…³é—­æŒ‰é’®å…ƒç´ æœªæ‰¾åˆ°');
            }

            // è¯¦ç»†ç»Ÿè®¡æŠ˜å 
            if (detailsToggle && detailsContent) {
                detailsToggle.addEventListener('click', () => {
                    console.log('è¯¦ç»†ç»Ÿè®¡æŠ˜å æŒ‰é’®è¢«ç‚¹å‡»');
                    detailsExpanded = !detailsExpanded;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? 'â–¼' : 'â–¶';
                    }
                    adjustWindowSize();
                });
            } else {
                console.error('è¯¦ç»†ç»Ÿè®¡æŠ˜å æŒ‰é’®æˆ–å†…å®¹å…ƒç´ æœªæ‰¾åˆ°');
            }

            // è®¾ç½®é¢æ¿
            if (closeSettingsBtn && overlaySettings) {
                closeSettingsBtn.addEventListener('click', () => {
                    console.log('å…³é—­è®¾ç½®æŒ‰é’®è¢«ç‚¹å‡»');
                    overlaySettings.style.display = 'none';
                });
            } else {
                console.error('å…³é—­è®¾ç½®æŒ‰é’®æˆ–è®¾ç½®é¢æ¿å…ƒç´ æœªæ‰¾åˆ°');
            }

            // é€æ˜åº¦è®¾ç½®
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', (e) => {
                    console.log('é€æ˜åº¦æ»‘å—è¢«è°ƒæ•´:', e.target.value);
                    opacity = parseInt(e.target.value);
                    opacityValue.textContent = opacity + '%';
                    document.body.style.opacity = opacity / 100;
                    saveSettings();
                });
            } else {
                console.error('é€æ˜åº¦æ»‘å—æˆ–æ˜¾ç¤ºå…ƒç´ æœªæ‰¾åˆ°');
            }

            // æ›´æ–°é¢‘ç‡è®¾ç½®
            if (updateFrequencySelect) {
                updateFrequencySelect.addEventListener('change', (e) => {
                    console.log('æ›´æ–°é¢‘ç‡è¢«ä¿®æ”¹:', e.target.value);
                    updateFreency = parseInt(e.target.value);
                    restartDataUpdate();
                    saveSettings();
                });
            } else {
                console.error('æ›´æ–°é¢‘ç‡é€‰æ‹©å…ƒç´ æœªæ‰¾åˆ°');
            }

            // é»˜è®¤æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
            if (showDetailsDefaultCheckbox && detailsContent) {
                showDetailsDefaultCheckbox.addEventListener('change', (e) => {
                    console.log('é»˜è®¤æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡å¤é€‰æ¡†è¢«ä¿®æ”¹:', e.target.checked);
                    detailsExpanded = e.target.checked;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? 'â–¼' : 'â–¶';
                    }
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('é»˜è®¤æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡å¤é€‰æ¡†æˆ–è¯¦ç»†å†…å®¹å…ƒç´ æœªæ‰¾åˆ°');
            }

            // éšè—HPSæ˜¾ç¤º
            if (hideHpsDisplayCheckbox) {
                hideHpsDisplayCheckbox.addEventListener('change', (e) => {
                    console.log('éšè—HPSæ˜¾ç¤ºå¤é€‰æ¡†è¢«ä¿®æ”¹:', e.target.checked);
                    hideHpsDisplay = e.target.checked;
                    toggleHpsDisplay();
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('éšè—HPSæ˜¾ç¤ºå¤é€‰æ¡†æœªæ‰¾åˆ°');
            }



            // åŸæ¥çš„æ•°æ®æ›´æ–°ç›‘å¬å™¨å·²ç§»åˆ°ä¸‹é¢ï¼Œæ·»åŠ äº†è°ƒè¯•ä¿¡æ¯

            // å®šæ—¶æ›´æ–°ç©å®¶ä¿¡æ¯å’Œæˆ˜åŠ›
            function updatePlayerInfo() {
                ipcRenderer.invoke('get-player-uid').then(currentUid => {
                    if (currentUid === null || currentUid === undefined) {
                        // æœªæ£€æµ‹åˆ°ç”¨æˆ·æ•°æ®
                        if (playerUid) {
                            playerUid.textContent = 'æœªæ£€æµ‹';
                            playerUid.title = '';
                            playerUid.style.color = '#f44336';
                        }
                        if (playerFightPoint) {
                            playerFightPoint.textContent = 'æœªæ£€æµ‹';
                            playerFightPoint.style.color = '#f44336';
                        }
                    } else {
                        // è·å–ç”¨æˆ·æ•°æ®
                        ipcRenderer.invoke('get-user-data', currentUid).then(userData => {
                            const displayName = userData ? userData.displayName : currentUid;
                            const fightPoint = userData ? userData.playerFightPoint : 0;
                            
                            if (playerUid) {
                                playerUid.textContent = displayName;
                                playerUid.title = `UID: ${currentUid}`;
                                playerUid.style.color = '#4CAF50';
                            }
                            
                            if (playerFightPoint) {
                                if (fightPoint > 0) {
                                    playerFightPoint.textContent = fightPoint.toLocaleString();
                                    playerFightPoint.style.color = '#4CAF50';
                                } else {
                                    playerFightPoint.textContent = 'æœªæ£€æµ‹';
                                    playerFightPoint.style.color = '#f44336';
                                }
                            }
                        }).catch(error => {
                            console.error('Error getting user data:', error);
                            if (playerUid) {
                                playerUid.textContent = 'è·å–å¤±è´¥';
                                playerUid.title = '';
                                playerUid.style.color = '#f44336';
                            }
                            if (playerFightPoint) {
                                playerFightPoint.textContent = 'è·å–å¤±è´¥';
                                playerFightPoint.style.color = '#f44336';
                            }
                        });
                    }
                }).catch(error => {
                    console.error('Error getting current UID:', error);
                    if (playerUid) {
                        playerUid.textContent = 'è·å–å¤±è´¥';
                        playerUid.title = '';
                        playerUid.style.color = '#f44336';
                    }
                    if (playerFightPoint) {
                        playerFightPoint.textContent = 'è·å–å¤±è´¥';
                        playerFightPoint.style.color = '#f44336';
                    }
                });
            }
            
            // ç«‹å³æ‰§è¡Œä¸€æ¬¡
            updatePlayerInfo();
            
            // æ¯éš”1ç§’æ›´æ–°ä¸€æ¬¡
            setInterval(updatePlayerInfo, 1000);

            // æ¥æ”¶"ä»…è‡ªå·±"æ¨¡å¼åˆ‡æ¢
            ipcRenderer.on('self-only-mode-changed', (event, enabled) => {
                console.log('æ‚¬æµ®çª—æ”¶åˆ°"ä»…è‡ªå·±"æ¨¡å¼åˆ‡æ¢:', enabled);
                selfOnlyMode = enabled;
                console.log('æ‚¬æµ®çª—"ä»…è‡ªå·±"æ¨¡å¼çŠ¶æ€å·²æ›´æ–°ä¸º:', selfOnlyMode);
            });

            // æ¥æ”¶æ•°æ®æ›´æ–°
            ipcRenderer.on('stats-updated', (event, data) => {
                console.log('æ‚¬æµ®çª—æ”¶åˆ°æ•°æ®æ›´æ–°:', {
                    selfOnlyMode: selfOnlyMode,
                    dataKeys: Object.keys(data),
                    dataCount: Object.keys(data).length
                });
                statsData = data;
                updateDpsDisplay();
            });
            
            // æ¥æ”¶æ•°æ®æ¸…ç©ºäº‹ä»¶ï¼ˆF10å¿«æ·é”®è§¦å‘ï¼‰
            ipcRenderer.on('stats-cleared', (event) => {
                console.log('æ‚¬æµ®çª—æ”¶åˆ°æ•°æ®æ¸…ç©ºäº‹ä»¶');
                statsData = {};
                updateDpsDisplay();
            });
            
            // æ¥æ”¶æ‚¬æµ®çª—é…ç½®æ›´æ–°
            ipcRenderer.on('overlay-settings-updated', (event, settings) => {
                console.log('æ‚¬æµ®çª—æ”¶åˆ°é…ç½®æ›´æ–°:', settings);
                applySettings(settings);
            });
        }

        // å¼€å§‹æ•°æ®æ›´æ–°
        function startDataUpdate() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                ipcRenderer.invoke('get-stats-data').then(data => {
                    if (data) {
                        statsData = data;
                        updateDpsDisplay();
                    }
                });
            }, updateFreency);

            // åˆå§‹åŒ–æ—¶çš„ç©å®¶ä¿¡æ¯è·å–å·²ç§»åˆ°updatePlayerInfoå‡½æ•°ä¸­
        }

        // é‡å¯æ•°æ®æ›´æ–°
        function restartDataUpdate() {
            startDataUpdate();
        }

        // è‡ªåŠ¨è°ƒæ•´çª—å£å¤§å°
        function adjustWindowSize() {
            // ç­‰å¾…DOMæ›´æ–°å®Œæˆ
            setTimeout(() => {
                const container = document.querySelector('.overlay-container');
                if (container) {
                    // è·å–å®¹å™¨çš„å®é™…å†…å®¹é«˜åº¦å’Œå®½åº¦
                    const containerRect = container.getBoundingClientRect();
                    const actualHeight = Math.max(container.scrollHeight, containerRect.height);
                    const actualWidth = Math.max(container.scrollWidth, containerRect.width) || 320;
                    
                    // è®¾ç½®æœ€å°é«˜åº¦å’Œå®½åº¦ï¼ˆç¡®ä¿çª—å£ä¸ä¼šå¤ªå°ï¼‰
                    const minHeight = 200;
                    const minWidth = 280;
                    
                    // è®¡ç®—æœ€ç»ˆå°ºå¯¸ï¼Œç¡®ä¿ä¸å°äºæœ€å°å€¼ï¼Œä¸å¤§äºæœ€å¤§å€¼
                    const finalHeight = Math.max(minHeight, Math.min(800, actualHeight));
                    const finalWidth = Math.max(minWidth, Math.min(500, actualWidth));
                    
                    // è°ƒæ•´çª—å£å¤§å°
                    ipcRenderer.invoke('overlay-resize', {
                        width: Math.ceil(finalWidth),
                        height: Math.ceil(finalHeight)
                    });
                }
            }, 100); // å¢åŠ å»¶è¿Ÿç¡®ä¿DOMå®Œå…¨æ¸²æŸ“
        }

        // åˆ‡æ¢HPSæ˜¾ç¤º
        function toggleHpsDisplay() {
            console.log('åˆ‡æ¢HPSæ˜¾ç¤ºçŠ¶æ€:', hideHpsDisplay);
            
            // éšè—æ•´ä¸ªHPSä¸»æ˜¾ç¤ºåŒºåŸŸ
            const hpsMain = document.querySelector('.hps-main');
            if (hpsMain) {
                hpsMain.style.display = hideHpsDisplay ? 'none' : '';
                console.log('HPSä¸»åŒºåŸŸæ˜¾ç¤ºçŠ¶æ€:', hpsMain.style.display);
            } else {
                console.error('æœªæ‰¾åˆ°.hps-mainå…ƒç´ ');
            }
            
            // éšè—è¯¦ç»†ç»Ÿè®¡ä¸­çš„HPSç›¸å…³é¡¹ç›®
            const totalHealingRow = document.getElementById('totalHealing')?.closest('.detail-row');
            const healingCountRow = document.getElementById('healingCount')?.closest('.detail-row');
            
            if (totalHealingRow) {
                totalHealingRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('æ€»æ²»ç–—è¡Œæ˜¾ç¤ºçŠ¶æ€:', totalHealingRow.style.display);
            } else {
                console.error('æœªæ‰¾åˆ°æ€»æ²»ç–—è¡Œå…ƒç´ ');
            }
            
            if (healingCountRow) {
                healingCountRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('æ²»ç–—æ¬¡æ•°è¡Œæ˜¾ç¤ºçŠ¶æ€:', healingCountRow.style.display);
            } else {
                console.error('æœªæ‰¾åˆ°æ²»ç–—æ¬¡æ•°è¡Œå…ƒç´ ');
            }
        }

        // æ›´æ–°DPSæ˜¾ç¤º
        function updateDpsDisplay() {
            const userIds = Object.keys(statsData);
            
            if (userIds.length === 0) {
                // æ— æ•°æ®æ—¶æ˜¾ç¤º0
                realtimeDps.textContent = '0';
                maxDps.textContent = '0';
                avgDps.textContent = '0';
                totalDamage.textContent = '0';
                realtimeHps.textContent = '0';
                maxHps.textContent = '0';
                avgHps.textContent = '0';
                totalHealing.textContent = '0';
                healingCount.textContent = '0';
                critRate.textContent = '0%';
                attackCount.textContent = '0';
                updateProgressBars(0, 0, 0, 0, 0, 0);
                adjustWindowSize();
                return;
            }

            // è®¡ç®—æ€»ä½“æ•°æ®
            let totalRealtimeDpsValue = 0;
            let totalMaxDpsValue = 0;
            let totalDamageValue = 0;
            let totalRealtimeHpsValue = 0;
            let totalMaxHpsValue = 0;
            let totalHealingValue = 0;
            let totalHealingCountValue = 0;
            let totalCritCount = 0;
            let totalAttackCount = 0;
            let earliestTime = null;
            let latestTime = null;

            for (const uid of userIds) {
                const userData = statsData[uid];
                totalRealtimeDpsValue += userData.realtime_dps || 0;
                totalMaxDpsValue = Math.max(totalMaxDpsValue, userData.realtime_dps_max || 0);
                totalDamageValue += userData.total_damage.total || 0;
                totalRealtimeHpsValue += userData.realtime_hps || 0;
                totalMaxHpsValue = Math.max(totalMaxHpsValue, userData.realtime_hps_max || 0);
                totalHealingValue += userData.total_healing ? userData.total_healing.total || 0 : 0;
                totalHealingCountValue += userData.healing_count ? userData.healing_count.total || 0 : 0;
                totalCritCount += userData.total_count.critical || 0;
                totalAttackCount += userData.total_count.total || 0;
                
                // è®¡ç®—æ€»ä½“æˆ˜æ–—æ—¶é—´èŒƒå›´
                if (userData.damage_time && userData.damage_time.length > 0) {
                    const userEarliest = userData.damage_time[0];
                    const userLatest = userData.damage_time[userData.damage_time.length - 1];
                    if (earliestTime === null || userEarliest < earliestTime) {
                        earliestTime = userEarliest;
                    }
                    if (latestTime === null || userLatest > latestTime) {
                        latestTime = userLatest;
                    }
                }
            }

            // è®¡ç®—çœŸæ­£çš„å¹³å‡DPSå’ŒHPS
            let totalAvgDpsValue = 0;
            let totalAvgHpsValue = 0;
            if (earliestTime && latestTime && latestTime > earliestTime) {
                const totalTimeDiff = latestTime - earliestTime;
                if (totalTimeDiff >= 1000) { // è‡³å°‘1ç§’
                    totalAvgDpsValue = (totalDamageValue / totalTimeDiff * 1000) || 0;
                    totalAvgHpsValue = (totalHealingValue / totalTimeDiff * 1000) || 0;
                }
            }

            const critRateValue = totalAttackCount > 0 ? (totalCritCount / totalAttackCount) : 0;

            // æ›´æ–°æ˜¾ç¤º
            realtimeDps.textContent = formatNumber(totalRealtimeDpsValue);
            maxDps.textContent = formatNumber(totalMaxDpsValue);
            avgDps.textContent = formatNumber(totalAvgDpsValue);
            totalDamage.textContent = formatNumber(totalDamageValue);
            realtimeHps.textContent = formatNumber(totalRealtimeHpsValue);
            maxHps.textContent = formatNumber(totalMaxHpsValue);
            avgHps.textContent = formatNumber(totalAvgHpsValue);
            totalHealing.textContent = formatNumber(totalHealingValue);
            healingCount.textContent = totalHealingCountValue.toString();
            critRate.textContent = (critRateValue * 100).toFixed(1) + '%';
            attackCount.textContent = totalAttackCount.toString();

            // æ›´æ–°è¿›åº¦æ¡
            updateProgressBars(totalRealtimeDpsValue, totalMaxDpsValue, totalAvgDpsValue, totalRealtimeHpsValue, totalMaxHpsValue, totalAvgHpsValue);
            
            // è°ƒæ•´çª—å£å¤§å°
            adjustWindowSize();
        }

        // æ›´æ–°è¿›åº¦æ¡
        function updateProgressBars(realtime, max, avg, realtimeHps, maxHps, avgHps) {
            // DPSè¿›åº¦æ¡
            const maxDpsValue = Math.max(realtime, max, avg) || 1;
            
            const realtimePercent = (realtime / maxDpsValue) * 100;
            const maxPercent = (max / maxDpsValue) * 100;
            const avgPercent = (avg / maxDpsValue) * 100;
            
            realtimeDpsBar.style.width = `${Math.min(realtimePercent, 100)}%`;
            maxDpsBar.style.width = `${Math.min(maxPercent, 100)}%`;
            avgDpsBar.style.width = `${Math.min(avgPercent, 100)}%`;
            
            // HPSè¿›åº¦æ¡
            const maxHpsValue = Math.max(realtimeHps, maxHps, avgHps) || 1;
            
            const realtimeHpsPercent = (realtimeHps / maxHpsValue) * 100;
            const maxHpsPercent = (maxHps / maxHpsValue) * 100;
            const avgHpsPercent = (avgHps / maxHpsValue) * 100;
            
            if (realtimeHpsBar) realtimeHpsBar.style.width = `${Math.min(realtimeHpsPercent, 100)}%`;
            if (maxHpsBar) maxHpsBar.style.width = `${Math.min(maxHpsPercent, 100)}%`;
            if (avgHpsBar) avgHpsBar.style.width = `${Math.min(avgHpsPercent, 100)}%`;
        }

        // æ ¼å¼åŒ–æ•°å­—
        function formatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            } else {
                return Math.floor(num).toString();
            }
        }

        // æ›´æ–°ç½®é¡¶æŒ‰é’®çŠ¶æ€
        function updatePinButton() {
            if (pinBtn) {
                const pinIcon = pinBtn.querySelector('span');
                if (isPinned) {
                    pinIcon.textContent = 'ğŸ“Œ';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = 'ç‚¹å‡»å–æ¶ˆç½®é¡¶';
                } else {
                    pinIcon.textContent = 'ğŸ“';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = 'ç‚¹å‡»ç½®é¡¶æ˜¾ç¤º';
                }
            }
        }

        // ä¿å­˜è®¾ç½®åˆ°localStorageå’Œmainè¿›ç¨‹
        function saveSettings() {
            const settings = {
                opacity,
                updateFreency,
                detailsExpanded,
                isPinned,
                hideHpsDisplay
            };
            localStorage.setItem('overlaySettings', JSON.stringify(settings));
            // åŒæ—¶ä¿å­˜åˆ°mainè¿›ç¨‹
            ipcRenderer.invoke('save-overlay-settings', settings);
            console.log('è®¾ç½®å·²ä¿å­˜:', settings);
        }
        
        // åº”ç”¨é…ç½®è®¾ç½®
        function applySettings(settings) {
            if (settings.opacity !== undefined) {
                opacity = settings.opacity;
                opacitySlider.value = opacity;
                opacityValue.textContent = opacity + '%';
                document.body.style.opacity = opacity / 100;
            }
            if (settings.updateFreency !== undefined) {
                updateFreency = settings.updateFreency;
                updateFrequencySelect.value = updateFreency;
                // é‡å¯æ•°æ®æ›´æ–°ä»¥åº”ç”¨æ–°çš„é¢‘ç‡
                restartDataUpdate();
            }
            if (settings.detailsExpanded !== undefined) {
                detailsExpanded = settings.detailsExpanded;
                showDetailsDefaultCheckbox.checked = detailsExpanded;
                detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                const arrow = document.querySelector('.details-arrow');
                if (arrow) {
                    arrow.textContent = detailsExpanded ? 'â–¼' : 'â–¶';
                }
                adjustWindowSize();
            }
            if (settings.isPinned !== undefined) {
                isPinned = settings.isPinned;
                ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                updatePinButton();
            }
            if (settings.hideHpsDisplay !== undefined) {
                hideHpsDisplay = settings.hideHpsDisplay;
                hideHpsDisplayCheckbox.checked = hideHpsDisplay;
                toggleHpsDisplay();
                adjustWindowSize();
            }
        }

        // ä»mainè¿›ç¨‹æˆ–localStorageåŠ è½½è®¾ç½®
        async function loadSettings() {
            try {
                // ä¼˜å…ˆä»mainè¿›ç¨‹è·å–é…ç½®
                const mainSettings = await ipcRenderer.invoke('get-overlay-settings');
                if (mainSettings) {
                    console.log('ä»mainè¿›ç¨‹åŠ è½½è®¾ç½®:', mainSettings);
                    applySettings(mainSettings);
                    return;
                }
            } catch (error) {
                console.log('ä»mainè¿›ç¨‹è·å–è®¾ç½®å¤±è´¥ï¼Œå°è¯•ä»localStorageåŠ è½½:', error);
            }
            
            // å¦‚æœmainè¿›ç¨‹æ²¡æœ‰é…ç½®ï¼Œåˆ™ä»localStorageåŠ è½½
            try {
                const settings = JSON.parse(localStorage.getItem('overlaySettings') || '{}');
                console.log('ä»localStorageåŠ è½½è®¾ç½®:', settings);
                applySettings(settings);
            } catch (error) {
                console.error('åŠ è½½è®¾ç½®å¤±è´¥:', error);
            }
        }

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        function setupResizeObserver() {
            if (typeof ResizeObserver !== 'undefined') {
                const container = document.querySelector('.overlay-container');
                if (container) {
                    const resizeObserver = new ResizeObserver(entries => {
                        // å½“å®¹å™¨å¤§å°å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒæ•´çª—å£å¤§å°
                        adjustWindowSize();
                    });
                    resizeObserver.observe(container);
                }
            }
        }
        
        // ç›‘å¬å†…å®¹å˜åŒ–
        function setupMutationObserver() {
            const overlayContent = document.querySelector('.overlay-content');
            if (overlayContent) {
                const mutationObserver = new MutationObserver(mutations => {
                    // å½“å†…å®¹å‘ç”Ÿå˜åŒ–æ—¶ï¼Œè°ƒæ•´çª—å£å¤§å°
                    adjustWindowSize();
                });
                mutationObserver.observe(overlayContent, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeOverlay();
            setupResizeObserver();
            setupMutationObserver();
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            // æ¸…ç†æ•°æ®å¼•ç”¨
            statsData = null;
        });
    </script>
</body>
</html>