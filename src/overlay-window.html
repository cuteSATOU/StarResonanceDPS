<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DPS悬浮窗</title>
    <link rel="stylesheet" href="overlay-window.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
</head>
<body>
    <div class="overlay-container">
        <!-- 悬浮窗头部（可拖拽） -->
        <div class="overlay-header" id="overlayHeader">
            <div class="overlay-title">
                <span class="overlay-icon">⚡</span>
                <span class="title-text">DPS监控</span>
            </div>
            <div class="overlay-controls">
                <button class="overlay-control-btn pin-btn" id="pinBtn" title="切换置顶">
                    <span>📌</span>
                </button>
                <button class="overlay-control-btn settings-btn" id="settingsBtn" title="设置">
                    <span>⚙️</span>
                </button>
                <button class="overlay-control-btn minimize-btn" id="minimizeBtn" title="最小化">
                    <span>–</span>
                </button>
                <button class="overlay-control-btn close-btn" id="closeBtn" title="关闭">
                    <span>✕</span>
                </button>
            </div>
        </div>

        <!-- DPS数据显示区域 -->
        <div class="overlay-content">
            <!-- 主要DPS指标 -->
            <div class="dps-main">
                <div class="dps-item primary">
                    <div class="dps-label">实时DPS</div>
                    <div class="dps-value" id="realtimeDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">峰值DPS</div>
                    <div class="dps-value" id="maxDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxDpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">平均DPS</div>
                    <div class="dps-value" id="avgDps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgDpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- 治疗数据显示区域 -->
            <div class="hps-main">
                <div class="dps-item primary">
                    <div class="dps-label">实时HPS</div>
                    <div class="dps-value" id="realtimeHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill" id="realtimeHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item secondary">
                    <div class="dps-label">峰值HPS</div>
                    <div class="dps-value" id="maxHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill max" id="maxHpsBar"></div>
                    </div>
                </div>
                
                <div class="dps-item tertiary">
                    <div class="dps-label">平均HPS</div>
                    <div class="dps-value" id="avgHps">0</div>
                    <div class="dps-bar">
                        <div class="dps-bar-fill avg" id="avgHpsBar"></div>
                    </div>
                </div>
            </div>

            <!-- 详细统计（可折叠） -->
            <div class="dps-details" id="dpsDetails">
                <div class="details-header" id="detailsToggle">
                    <span class="details-title">详细统计</span>
                    <span class="details-arrow">▼</span>
                </div>
                <div class="details-content" id="detailsContent">
                    <div class="detail-row">
                        <span class="detail-label">总伤害</span>
                        <span class="detail-value" id="totalDamage">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">总治疗</span>
                        <span class="detail-value" id="totalHealing">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">暴击率</span>
                        <span class="detail-value" id="critRate">0%</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">攻击次数</span>
                        <span class="detail-value" id="attackCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">治疗次数</span>
                        <span class="detail-value" id="healingCount">0</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">玩家</span>
                        <span class="detail-value" id="playerUid">未检测</span>
                    </div>
                    <div class="detail-row">
                        <span class="detail-label">战力</span>
                        <span class="detail-value" id="playerFightPoint">未检测</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 设置面板（隐藏） -->
        <div class="overlay-settings" id="overlaySettings" style="display: none;">
            <div class="settings-header">
                <h4>悬浮窗设置</h4>
                <button class="close-settings-btn" id="closeSettingsBtn">✕</button>
            </div>
            <div class="settings-content">
                <div class="setting-item">
                    <label>透明度</label>
                    <input type="range" id="opacitySlider" min="30" max="100" value="90" step="10">
                    <span id="opacityValue">90%</span>
                </div>
                <div class="setting-item">
                    <label>更新频率</label>
                    <select id="updateFrequency">
                        <option value="100">100ms (流畅)</option>
                        <option value="250" selected>250ms (平衡)</option>
                        <option value="500">500ms (节能)</option>
                    </select>
                </div>
                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDetailsDefault" checked>
                        <span class="checkbox-custom"></span>
                        默认显示详细统计
                    </label>
                </div>

                <div class="setting-item">
                    <label class="checkbox-label">
                        <input type="checkbox" id="hideHpsDisplay">
                        <span class="checkbox-custom"></span>
                        隐藏HPS显示
                    </label>
                </div>

            </div>
        </div>
    </div>

    <script>
        const { ipcRenderer } = require('electron');

        let statsData = {};
        let detailsExpanded = true;
        let updateInterval = null;
        let updateFreency = 500; // 默认降低更新频率以节省性能
        let opacity = 90;
        let isPinned = true;
        let hideHpsDisplay = false;
        let selfOnlyMode = false;

        // DOM元素
        let realtimeDps, maxDps, avgDps, totalDamage, critRate, attackCount, playerUid, playerFightPoint;
        let realtimeHps, maxHps, avgHps, totalHealing, healingCount;
        let realtimeDpsBar, maxDpsBar, avgDpsBar;
        let realtimeHpsBar, maxHpsBar, avgHpsBar;
        let pinBtn, settingsBtn, minimizeBtn, closeBtn;
        let detailsToggle, detailsContent;
        let overlaySettings, closeSettingsBtn, opacitySlider, opacityValue, updateFrequencySelect;
        let showDetailsDefaultCheckbox, hideHpsDisplayCheckbox;

        // 初始化
        async function initializeOverlay() {
            // 获取DOM元素
            realtimeDps = document.getElementById('realtimeDps');
            maxDps = document.getElementById('maxDps');
            avgDps = document.getElementById('avgDps');
            totalDamage = document.getElementById('totalDamage');
            realtimeHps = document.getElementById('realtimeHps');
            maxHps = document.getElementById('maxHps');
            avgHps = document.getElementById('avgHps');
            totalHealing = document.getElementById('totalHealing');
            healingCount = document.getElementById('healingCount');
            critRate = document.getElementById('critRate');
            attackCount = document.getElementById('attackCount');
            playerUid = document.getElementById('playerUid');
            playerFightPoint = document.getElementById('playerFightPoint');
            
            // 调试：检查DOM元素是否正确获取
            console.log('悬浮窗DOM元素初始化:', {
                playerUid: playerUid,
                playerUidExists: !!playerUid
            });
            
            realtimeDpsBar = document.getElementById('realtimeDpsBar');
            maxDpsBar = document.getElementById('maxDpsBar');
            avgDpsBar = document.getElementById('avgDpsBar');
            realtimeHpsBar = document.getElementById('realtimeHpsBar');
            maxHpsBar = document.getElementById('maxHpsBar');
            avgHpsBar = document.getElementById('avgHpsBar');
            
            pinBtn = document.getElementById('pinBtn');
            settingsBtn = document.getElementById('settingsBtn');
            minimizeBtn = document.getElementById('minimizeBtn');
            closeBtn = document.getElementById('closeBtn');
            detailsToggle = document.getElementById('detailsToggle');
            detailsContent = document.getElementById('detailsContent');
            
            overlaySettings = document.getElementById('overlaySettings');
            closeSettingsBtn = document.getElementById('closeSettingsBtn');
            opacitySlider = document.getElementById('opacitySlider');
            opacityValue = document.getElementById('opacityValue');
            updateFrequencySelect = document.getElementById('updateFrequency');
            showDetailsDefaultCheckbox = document.getElementById('showDetailsDefault');
            hideHpsDisplayCheckbox = document.getElementById('hideHpsDisplay');

            bindEvents();
            await loadSettings();
            updatePinButton();
            
            // 确保详细统计默认展开
            if (detailsContent) {
                detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                const arrow = document.querySelector('.details-arrow');
                if (arrow) {
                    arrow.textContent = detailsExpanded ? '▼' : '▶';
                }
                console.log('详细统计展开状态:', detailsExpanded);
            }
            
            startDataUpdate();
            
            // 初始化时调整窗口大小
            setTimeout(() => {
                adjustWindowSize();
            }, 100);
        }

        // 绑定事件
        function bindEvents() {
            console.log('开始绑定事件，检查DOM元素:', {
                pinBtn: !!pinBtn,
                settingsBtn: !!settingsBtn,
                minimizeBtn: !!minimizeBtn,
                closeBtn: !!closeBtn,
                detailsToggle: !!detailsToggle,
                closeSettingsBtn: !!closeSettingsBtn,
                opacitySlider: !!opacitySlider,
                updateFrequencySelect: !!updateFrequencySelect,
                showDetailsDefaultCheckbox: !!showDetailsDefaultCheckbox
            });

            // 置顶按钮
            if (pinBtn) {
                pinBtn.addEventListener('click', () => {
                    console.log('置顶按钮被点击');
                    isPinned = !isPinned;
                    ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                    updatePinButton();
                });
            } else {
                console.error('置顶按钮元素未找到');
            }

            // 控制按钮
            if (settingsBtn && overlaySettings) {
                settingsBtn.addEventListener('click', () => {
                    console.log('设置按钮被点击');
                    overlaySettings.style.display = overlaySettings.style.display === 'none' ? 'block' : 'none';
                });
            } else {
                console.error('设置按钮或设置面板元素未找到');
            }

            if (minimizeBtn) {
                minimizeBtn.addEventListener('click', () => {
                    console.log('最小化按钮被点击');
                    ipcRenderer.invoke('overlay-minimize');
                });
            } else {
                console.error('最小化按钮元素未找到');
            }

            if (closeBtn) {
                closeBtn.addEventListener('click', () => {
                    console.log('关闭按钮被点击');
                    ipcRenderer.invoke('overlay-close');
                });
            } else {
                console.error('关闭按钮元素未找到');
            }

            // 详细统计折叠
            if (detailsToggle && detailsContent) {
                detailsToggle.addEventListener('click', () => {
                    console.log('详细统计折叠按钮被点击');
                    detailsExpanded = !detailsExpanded;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? '▼' : '▶';
                    }
                    adjustWindowSize();
                });
            } else {
                console.error('详细统计折叠按钮或内容元素未找到');
            }

            // 设置面板
            if (closeSettingsBtn && overlaySettings) {
                closeSettingsBtn.addEventListener('click', () => {
                    console.log('关闭设置按钮被点击');
                    overlaySettings.style.display = 'none';
                });
            } else {
                console.error('关闭设置按钮或设置面板元素未找到');
            }

            // 透明度设置
            if (opacitySlider && opacityValue) {
                opacitySlider.addEventListener('input', (e) => {
                    console.log('透明度滑块被调整:', e.target.value);
                    opacity = parseInt(e.target.value);
                    opacityValue.textContent = opacity + '%';
                    document.body.style.opacity = opacity / 100;
                    saveSettings();
                });
            } else {
                console.error('透明度滑块或显示元素未找到');
            }

            // 更新频率设置
            if (updateFrequencySelect) {
                updateFrequencySelect.addEventListener('change', (e) => {
                    console.log('更新频率被修改:', e.target.value);
                    updateFreency = parseInt(e.target.value);
                    restartDataUpdate();
                    saveSettings();
                });
            } else {
                console.error('更新频率选择元素未找到');
            }

            // 默认显示详细统计
            if (showDetailsDefaultCheckbox && detailsContent) {
                showDetailsDefaultCheckbox.addEventListener('change', (e) => {
                    console.log('默认显示详细统计复选框被修改:', e.target.checked);
                    detailsExpanded = e.target.checked;
                    detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                    const arrow = document.querySelector('.details-arrow');
                    if (arrow) {
                        arrow.textContent = detailsExpanded ? '▼' : '▶';
                    }
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('默认显示详细统计复选框或详细内容元素未找到');
            }

            // 隐藏HPS显示
            if (hideHpsDisplayCheckbox) {
                hideHpsDisplayCheckbox.addEventListener('change', (e) => {
                    console.log('隐藏HPS显示复选框被修改:', e.target.checked);
                    hideHpsDisplay = e.target.checked;
                    toggleHpsDisplay();
                    adjustWindowSize();
                    saveSettings();
                });
            } else {
                console.error('隐藏HPS显示复选框未找到');
            }



            // 原来的数据更新监听器已移到下面，添加了调试信息

            // 定时更新玩家信息和战力
            function updatePlayerInfo() {
                ipcRenderer.invoke('get-player-uid').then(currentUid => {
                    if (currentUid === null || currentUid === undefined) {
                        // 未检测到用户数据
                        if (playerUid) {
                            playerUid.textContent = '未检测';
                            playerUid.title = '';
                            playerUid.style.color = '#f44336';
                        }
                        if (playerFightPoint) {
                            playerFightPoint.textContent = '未检测';
                            playerFightPoint.style.color = '#f44336';
                        }
                    } else {
                        // 获取用户数据
                        ipcRenderer.invoke('get-user-data', currentUid).then(userData => {
                            const displayName = userData ? userData.displayName : currentUid;
                            const fightPoint = userData ? userData.playerFightPoint : 0;
                            
                            if (playerUid) {
                                playerUid.textContent = displayName;
                                playerUid.title = `UID: ${currentUid}`;
                                playerUid.style.color = '#4CAF50';
                            }
                            
                            if (playerFightPoint) {
                                if (fightPoint > 0) {
                                    playerFightPoint.textContent = fightPoint.toLocaleString();
                                    playerFightPoint.style.color = '#4CAF50';
                                } else {
                                    playerFightPoint.textContent = '未检测';
                                    playerFightPoint.style.color = '#f44336';
                                }
                            }
                        }).catch(error => {
                            console.error('Error getting user data:', error);
                            if (playerUid) {
                                playerUid.textContent = '获取失败';
                                playerUid.title = '';
                                playerUid.style.color = '#f44336';
                            }
                            if (playerFightPoint) {
                                playerFightPoint.textContent = '获取失败';
                                playerFightPoint.style.color = '#f44336';
                            }
                        });
                    }
                }).catch(error => {
                    console.error('Error getting current UID:', error);
                    if (playerUid) {
                        playerUid.textContent = '获取失败';
                        playerUid.title = '';
                        playerUid.style.color = '#f44336';
                    }
                    if (playerFightPoint) {
                        playerFightPoint.textContent = '获取失败';
                        playerFightPoint.style.color = '#f44336';
                    }
                });
            }
            
            // 立即执行一次
            updatePlayerInfo();
            
            // 每隔1秒更新一次
            setInterval(updatePlayerInfo, 1000);

            // 接收"仅自己"模式切换
            ipcRenderer.on('self-only-mode-changed', (event, enabled) => {
                console.log('悬浮窗收到"仅自己"模式切换:', enabled);
                selfOnlyMode = enabled;
                console.log('悬浮窗"仅自己"模式状态已更新为:', selfOnlyMode);
            });

            // 接收数据更新
            ipcRenderer.on('stats-updated', (event, data) => {
                console.log('悬浮窗收到数据更新:', {
                    selfOnlyMode: selfOnlyMode,
                    dataKeys: Object.keys(data),
                    dataCount: Object.keys(data).length
                });
                statsData = data;
                updateDpsDisplay();
            });
            
            // 接收数据清空事件（F10快捷键触发）
            ipcRenderer.on('stats-cleared', (event) => {
                console.log('悬浮窗收到数据清空事件');
                statsData = {};
                updateDpsDisplay();
            });
            
            // 接收悬浮窗配置更新
            ipcRenderer.on('overlay-settings-updated', (event, settings) => {
                console.log('悬浮窗收到配置更新:', settings);
                applySettings(settings);
            });
        }

        // 开始数据更新
        function startDataUpdate() {
            if (updateInterval) {
                clearInterval(updateInterval);
            }
            updateInterval = setInterval(() => {
                ipcRenderer.invoke('get-stats-data').then(data => {
                    if (data) {
                        statsData = data;
                        updateDpsDisplay();
                    }
                });
            }, updateFreency);

            // 初始化时的玩家信息获取已移到updatePlayerInfo函数中
        }

        // 重启数据更新
        function restartDataUpdate() {
            startDataUpdate();
        }

        // 自动调整窗口大小
        function adjustWindowSize() {
            // 等待DOM更新完成
            setTimeout(() => {
                const container = document.querySelector('.overlay-container');
                if (container) {
                    // 获取容器的实际内容高度和宽度
                    const containerRect = container.getBoundingClientRect();
                    const actualHeight = Math.max(container.scrollHeight, containerRect.height);
                    const actualWidth = Math.max(container.scrollWidth, containerRect.width) || 320;
                    
                    // 设置最小高度和宽度（确保窗口不会太小）
                    const minHeight = 200;
                    const minWidth = 280;
                    
                    // 计算最终尺寸，确保不小于最小值，不大于最大值
                    const finalHeight = Math.max(minHeight, Math.min(800, actualHeight));
                    const finalWidth = Math.max(minWidth, Math.min(500, actualWidth));
                    
                    // 调整窗口大小
                    ipcRenderer.invoke('overlay-resize', {
                        width: Math.ceil(finalWidth),
                        height: Math.ceil(finalHeight)
                    });
                }
            }, 100); // 增加延迟确保DOM完全渲染
        }

        // 切换HPS显示
        function toggleHpsDisplay() {
            console.log('切换HPS显示状态:', hideHpsDisplay);
            
            // 隐藏整个HPS主显示区域
            const hpsMain = document.querySelector('.hps-main');
            if (hpsMain) {
                hpsMain.style.display = hideHpsDisplay ? 'none' : '';
                console.log('HPS主区域显示状态:', hpsMain.style.display);
            } else {
                console.error('未找到.hps-main元素');
            }
            
            // 隐藏详细统计中的HPS相关项目
            const totalHealingRow = document.getElementById('totalHealing')?.closest('.detail-row');
            const healingCountRow = document.getElementById('healingCount')?.closest('.detail-row');
            
            if (totalHealingRow) {
                totalHealingRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('总治疗行显示状态:', totalHealingRow.style.display);
            } else {
                console.error('未找到总治疗行元素');
            }
            
            if (healingCountRow) {
                healingCountRow.style.display = hideHpsDisplay ? 'none' : '';
                console.log('治疗次数行显示状态:', healingCountRow.style.display);
            } else {
                console.error('未找到治疗次数行元素');
            }
        }

        // 更新DPS显示
        function updateDpsDisplay() {
            const userIds = Object.keys(statsData);
            
            if (userIds.length === 0) {
                // 无数据时显示0
                realtimeDps.textContent = '0';
                maxDps.textContent = '0';
                avgDps.textContent = '0';
                totalDamage.textContent = '0';
                realtimeHps.textContent = '0';
                maxHps.textContent = '0';
                avgHps.textContent = '0';
                totalHealing.textContent = '0';
                healingCount.textContent = '0';
                critRate.textContent = '0%';
                attackCount.textContent = '0';
                updateProgressBars(0, 0, 0, 0, 0, 0);
                adjustWindowSize();
                return;
            }

            // 计算总体数据
            let totalRealtimeDpsValue = 0;
            let totalMaxDpsValue = 0;
            let totalDamageValue = 0;
            let totalRealtimeHpsValue = 0;
            let totalMaxHpsValue = 0;
            let totalHealingValue = 0;
            let totalHealingCountValue = 0;
            let totalCritCount = 0;
            let totalAttackCount = 0;
            let earliestTime = null;
            let latestTime = null;

            for (const uid of userIds) {
                const userData = statsData[uid];
                totalRealtimeDpsValue += userData.realtime_dps || 0;
                totalMaxDpsValue = Math.max(totalMaxDpsValue, userData.realtime_dps_max || 0);
                totalDamageValue += userData.total_damage.total || 0;
                totalRealtimeHpsValue += userData.realtime_hps || 0;
                totalMaxHpsValue = Math.max(totalMaxHpsValue, userData.realtime_hps_max || 0);
                totalHealingValue += userData.total_healing ? userData.total_healing.total || 0 : 0;
                totalHealingCountValue += userData.healing_count ? userData.healing_count.total || 0 : 0;
                totalCritCount += userData.total_count.critical || 0;
                totalAttackCount += userData.total_count.total || 0;
                
                // 计算总体战斗时间范围
                if (userData.damage_time && userData.damage_time.length > 0) {
                    const userEarliest = userData.damage_time[0];
                    const userLatest = userData.damage_time[userData.damage_time.length - 1];
                    if (earliestTime === null || userEarliest < earliestTime) {
                        earliestTime = userEarliest;
                    }
                    if (latestTime === null || userLatest > latestTime) {
                        latestTime = userLatest;
                    }
                }
            }

            // 计算真正的平均DPS和HPS
            let totalAvgDpsValue = 0;
            let totalAvgHpsValue = 0;
            if (earliestTime && latestTime && latestTime > earliestTime) {
                const totalTimeDiff = latestTime - earliestTime;
                if (totalTimeDiff >= 1000) { // 至少1秒
                    totalAvgDpsValue = (totalDamageValue / totalTimeDiff * 1000) || 0;
                    totalAvgHpsValue = (totalHealingValue / totalTimeDiff * 1000) || 0;
                }
            }

            const critRateValue = totalAttackCount > 0 ? (totalCritCount / totalAttackCount) : 0;

            // 更新显示
            realtimeDps.textContent = formatNumber(totalRealtimeDpsValue);
            maxDps.textContent = formatNumber(totalMaxDpsValue);
            avgDps.textContent = formatNumber(totalAvgDpsValue);
            totalDamage.textContent = formatNumber(totalDamageValue);
            realtimeHps.textContent = formatNumber(totalRealtimeHpsValue);
            maxHps.textContent = formatNumber(totalMaxHpsValue);
            avgHps.textContent = formatNumber(totalAvgHpsValue);
            totalHealing.textContent = formatNumber(totalHealingValue);
            healingCount.textContent = totalHealingCountValue.toString();
            critRate.textContent = (critRateValue * 100).toFixed(1) + '%';
            attackCount.textContent = totalAttackCount.toString();

            // 更新进度条
            updateProgressBars(totalRealtimeDpsValue, totalMaxDpsValue, totalAvgDpsValue, totalRealtimeHpsValue, totalMaxHpsValue, totalAvgHpsValue);
            
            // 调整窗口大小
            adjustWindowSize();
        }

        // 更新进度条
        function updateProgressBars(realtime, max, avg, realtimeHps, maxHps, avgHps) {
            // DPS进度条
            const maxDpsValue = Math.max(realtime, max, avg) || 1;
            
            const realtimePercent = (realtime / maxDpsValue) * 100;
            const maxPercent = (max / maxDpsValue) * 100;
            const avgPercent = (avg / maxDpsValue) * 100;
            
            realtimeDpsBar.style.width = `${Math.min(realtimePercent, 100)}%`;
            maxDpsBar.style.width = `${Math.min(maxPercent, 100)}%`;
            avgDpsBar.style.width = `${Math.min(avgPercent, 100)}%`;
            
            // HPS进度条
            const maxHpsValue = Math.max(realtimeHps, maxHps, avgHps) || 1;
            
            const realtimeHpsPercent = (realtimeHps / maxHpsValue) * 100;
            const maxHpsPercent = (maxHps / maxHpsValue) * 100;
            const avgHpsPercent = (avgHps / maxHpsValue) * 100;
            
            if (realtimeHpsBar) realtimeHpsBar.style.width = `${Math.min(realtimeHpsPercent, 100)}%`;
            if (maxHpsBar) maxHpsBar.style.width = `${Math.min(maxHpsPercent, 100)}%`;
            if (avgHpsBar) avgHpsBar.style.width = `${Math.min(avgHpsPercent, 100)}%`;
        }

        // 格式化数字
        function formatNumber(num) {
            if (typeof num !== 'number' || isNaN(num)) return '0';
            
            if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            } else {
                return Math.floor(num).toString();
            }
        }

        // 更新置顶按钮状态
        function updatePinButton() {
            if (pinBtn) {
                const pinIcon = pinBtn.querySelector('span');
                if (isPinned) {
                    pinIcon.textContent = '📌';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.3)';
                    pinBtn.title = '点击取消置顶';
                } else {
                    pinIcon.textContent = '📍';
                    pinBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    pinBtn.title = '点击置顶显示';
                }
            }
        }

        // 保存设置到localStorage和main进程
        function saveSettings() {
            const settings = {
                opacity,
                updateFreency,
                detailsExpanded,
                isPinned,
                hideHpsDisplay
            };
            localStorage.setItem('overlaySettings', JSON.stringify(settings));
            // 同时保存到main进程
            ipcRenderer.invoke('save-overlay-settings', settings);
            console.log('设置已保存:', settings);
        }
        
        // 应用配置设置
        function applySettings(settings) {
            if (settings.opacity !== undefined) {
                opacity = settings.opacity;
                opacitySlider.value = opacity;
                opacityValue.textContent = opacity + '%';
                document.body.style.opacity = opacity / 100;
            }
            if (settings.updateFreency !== undefined) {
                updateFreency = settings.updateFreency;
                updateFrequencySelect.value = updateFreency;
                // 重启数据更新以应用新的频率
                restartDataUpdate();
            }
            if (settings.detailsExpanded !== undefined) {
                detailsExpanded = settings.detailsExpanded;
                showDetailsDefaultCheckbox.checked = detailsExpanded;
                detailsContent.style.display = detailsExpanded ? 'block' : 'none';
                const arrow = document.querySelector('.details-arrow');
                if (arrow) {
                    arrow.textContent = detailsExpanded ? '▼' : '▶';
                }
                adjustWindowSize();
            }
            if (settings.isPinned !== undefined) {
                isPinned = settings.isPinned;
                ipcRenderer.invoke('overlay-set-always-on-top', isPinned);
                updatePinButton();
            }
            if (settings.hideHpsDisplay !== undefined) {
                hideHpsDisplay = settings.hideHpsDisplay;
                hideHpsDisplayCheckbox.checked = hideHpsDisplay;
                toggleHpsDisplay();
                adjustWindowSize();
            }
        }

        // 从main进程或localStorage加载设置
        async function loadSettings() {
            try {
                // 优先从main进程获取配置
                const mainSettings = await ipcRenderer.invoke('get-overlay-settings');
                if (mainSettings) {
                    console.log('从main进程加载设置:', mainSettings);
                    applySettings(mainSettings);
                    return;
                }
            } catch (error) {
                console.log('从main进程获取设置失败，尝试从localStorage加载:', error);
            }
            
            // 如果main进程没有配置，则从localStorage加载
            try {
                const settings = JSON.parse(localStorage.getItem('overlaySettings') || '{}');
                console.log('从localStorage加载设置:', settings);
                applySettings(settings);
            } catch (error) {
                console.error('加载设置失败:', error);
            }
        }

        // 监听窗口大小变化
        function setupResizeObserver() {
            if (typeof ResizeObserver !== 'undefined') {
                const container = document.querySelector('.overlay-container');
                if (container) {
                    const resizeObserver = new ResizeObserver(entries => {
                        // 当容器大小发生变化时，调整窗口大小
                        adjustWindowSize();
                    });
                    resizeObserver.observe(container);
                }
            }
        }
        
        // 监听内容变化
        function setupMutationObserver() {
            const overlayContent = document.querySelector('.overlay-content');
            if (overlayContent) {
                const mutationObserver = new MutationObserver(mutations => {
                    // 当内容发生变化时，调整窗口大小
                    adjustWindowSize();
                });
                mutationObserver.observe(overlayContent, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeFilter: ['style', 'class']
                });
            }
        }

        // 页面加载完成后初始化
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeOverlay();
            setupResizeObserver();
            setupMutationObserver();
        });

        // 页面卸载时清理
        window.addEventListener('beforeunload', () => {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
            // 清理数据引用
            statsData = null;
        });
    </script>
</body>
</html>